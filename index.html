
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>PyNUFFT 2020.1.0 documentation</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">PyNUFFT 2020.1.0  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-overview/init">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/pynufft">The Python Non-uniform fast Fourier transform (PyNUFFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/Nd_NUFFT">Multi-dimensional NUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/CPU_GPU">CPU and GPU (HSA)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutor/init">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/basic_use">Basic use of PyNUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/example">The 1D example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/more2D">The 2D example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/more3D">A 3D example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-manu/init">Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/NUFFT_cpu">NUFFT_cpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/NUFFT_hsa">NUFFT_hsa</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/multiple_NUFFT">Multiple NUFFT instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#multiprocessing-experimental">Multiprocessing (experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/batch_mode">Batched NUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/mcoil">Multi-coil NUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/realistic_om">k-Space trajectories (om)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/variable_radix">Radix-1, Radix-2 and mixed radix NUFFT (advanced)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-API/init">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#nufft-cpu-class">NUFFT CPU class</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nufft-hsa-classes">NUFFT HSA classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cpu-solvers">CPU solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#hsa-solvers">HSA solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#helper-functions">Helper functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#metaprogramming-subroutines-using-reikna-pyopencl-pycuda">Metaprogramming subroutines (using reikna, pyopencl, pycuda)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-installation/init">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#system-requirements">System requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#software">Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#general-installation">General Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#special-topics">Special topics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-versionhistory">Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-acknow/init">Acknowledgements</a></li>
</ul>

    </div>
  </div>
</div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html#document-index">Docs</a></li>
              
              <li>PyNUFFT 2020.1.0  documentation</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="welcome-to-pynufft-s-user-manual">
<h1>Welcome to PyNUFFT’s User Manual!<a class="headerlink" href="#welcome-to-pynufft-s-user-manual" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-overview/init"></span><div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-overview/pynufft"></span><div class="section" id="the-python-non-uniform-fast-fourier-transform-pynufft">
<h3>The Python Non-uniform fast Fourier transform (PyNUFFT)<a class="headerlink" href="#the-python-non-uniform-fast-fourier-transform-pynufft" title="Permalink to this headline">¶</a></h3>
<p><strong>Purpose</strong></p>
<p>The PyNUFFT user manual documents the <em>Python non-uniform fast Fourier transform</em>, a Python package for non-uniform fast Fourier transform.</p>
<p>PyNUFFT was created for fun. The content may not reflect the views of funding bodies, former or current partners, and contributors.</p>
<p>If you find PyNUFFT useful, please cite:</p>
<p><em>Lin, Jyh-Miin. “Python Non-Uniform Fast Fourier Transform (PyNUFFT): An Accelerated Non-Cartesian MRI Package on a Heterogeneous Platform (CPU/GPU).” Journal of Imaging 4.3 (2018): 51.</em></p>
<p>or</p>
<p><em>J.-M. Lin and H.-W. Chung, Pynufft: python non-uniform fast Fourier transform for MRI Building Bridges in Medical Sciences 2017, St John’s College, CB2 1TP Cambridge, UK</em></p>
<p>Users of PyNUFFT should be familiar with discrete Fourier transform (DFT).</p>
<p><strong>The min-max interpolator</strong></p>
<ul class="simple">
<li><p>PyNUFFT translates the min-max interpolator to Python. The min-max interpolator is described in the literature:</p></li>
</ul>
<p><em>Fessler JA, Sutton BP. Nonuniform fast Fourier transforms using min-max interpolation. IEEE Trans Signal Process 2003;51(2):560-574.</em></p>
<p><strong>Background</strong></p>
<ul class="simple">
<li><p>Fast Fourier transform (FFT) is one of the most important algorithms in signal processing. FFT delivers a fast and exact discrete Fourier transform (DFT) in a much shorter computation time than direct DFT does.</p></li>
<li><p>However, FFT does not handle non-Cartesian DFT.</p></li>
<li><p>Thus, NUFFT is proposed as a way to compute the spectrum, by leveraging the speed of FFT and fast interpolation.</p></li>
</ul>
<p><strong>Current status of PyNUFFT</strong></p>
<ul class="simple">
<li><p>The current PyNUFFT relies on Numpy/Scipy (NUFFT_cpu) and Reikan/PyCUDA/PyOpenCL (NUFFT_hsa).</p></li>
<li><p>PyNUFFT provides 3 NUFFT classes: (1) NUFFT_cpu, (2) NUFFT_hsa (HSA: heterogeneous system architecture), (3) NUFFT (mixed CPU/HSA classes without warranty)</p></li>
<li><p>LGPLv3.</p></li>
</ul>
</div>
<span id="document-overview/Nd_NUFFT"></span><div class="section" id="multi-dimensional-nufft">
<h3>Multi-dimensional NUFFT<a class="headerlink" href="#multi-dimensional-nufft" title="Permalink to this headline">¶</a></h3>
<p>Multi-dimensional transforms are supported by PyNUFFT.</p>
<p>The dimensionality of an imaging reconstruction problem is revealed as
the number of axes of the Nd (or Kd, Jd) tuples.</p>
<p>For example, Nd = (256,256) indicates a 2D imaging reconstruction problem,
in which the sizes of the x-y axes are 256 and 256, respectively.</p>
<p>Normally, the matrix size of the k-space is twice the size of Nd. For example,
Kd = (512,512) is appropriate for the above Nd = (256,256) problem.</p>
<p>In batch mode, the ‘batch’ argument controls the number of channels.
This will not affect the dimensionality of the image reconstruction problem.
The batch model will be detailed in the ‘batched NUFFT’ section.</p>
<p><a class="reference internal" href="#configuration-nufft"><span class="std std-numref">Fig. 1</span></a> illustrates the variables for 1D, 2D, 3D NUFFT.</p>
<div class="figure align-center" id="id1">
<span id="configuration-nufft"></span><a class="reference internal image-reference" href="_images/configuration_nufft.png"><img alt="_images/configuration_nufft.png" src="_images/configuration_nufft.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Configuration of 1D, 2D, and 3D NUFFT.
(A) 1D NUFFT: om is a numpy.array of the shape (M,1).
M is the number of non-Cartesian points.
Nd = (8, ) is the image domain grid size and Kd = (16, ) is the oversampled grid size.
Jd = (6, ) is the interpolator size.
(B) 2D NUFFT: om is a numpy.array of the shape (M,2).
M is the number of non-Cartesian points.
Nd = (8, 8 ) is the image domain grid size and Kd = (16, 16 ) is the oversampled grid size.
Jd = (6, 6 ) is the interpolator size.
(C) 3D NUFFT: om is a numpy.array of the shape (M,3).
M is the number of non-Cartesian points.
Nd = (8, 8, 8 ) is the image domain grid size and Kd = (16, 16, 16 ) is the oversampled grid size.
Jd = (6, 6, 6 ) is the interpolator size.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<span id="document-overview/CPU_GPU"></span><div class="section" id="cpu-and-gpu-hsa">
<h3>CPU and GPU (HSA)<a class="headerlink" href="#cpu-and-gpu-hsa" title="Permalink to this headline">¶</a></h3>
<p>The PyNUFFT ran originally on Numpy/Scipy. Unfortunately the default Numpy/Scipy is most efficient on a single CPU core.</p>
<p>Later it was ported to PyCUDA and PyOpenCL, which allows us to leverage the speed of multi-core CPU and GPU.</p>
<p>Mixing NUFFT_cpu and NUFFT_hsa, or multiple NUFFT_cpu or multiple NUFFT_hsa is possible but has no warranty.</p>
<p>The class methods are listed in <a class="reference internal" href="#dimension-table"><span class="std std-numref">Table 1</span></a></p>
<span id="dimension-table"></span><table class="colwidths-given docutils align-center" id="id1">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Methods implemented in NUFFT_cpu and NUFFT_hsa</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>method name</p></th>
<th class="head"><p>NUFFT_cpu</p></th>
<th class="head"><p>NUFFT_hsa</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__init__()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Constructor</p></td>
</tr>
<tr class="row-odd"><td><p>plan()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Planning the instance</p></td>
</tr>
<tr class="row-even"><td><p>forward()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Forward NUFFT <span class="math notranslate nohighlight">\(A\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>adjoint()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Adjoint NUFFT <span class="math notranslate nohighlight">\(A^H\)</span></p></td>
</tr>
<tr class="row-even"><td><p>forward_one2many()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(batch mode) Single image -&gt; multi-coil data forward NUFFT <span class="math notranslate nohighlight">\(A\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>adjoint_many2one()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(batch mode) Multi-coil data -&gt; single image adjoint NUFFT <span class="math notranslate nohighlight">\(A^H\)</span></p></td>
</tr>
<tr class="row-even"><td><p>selfadjoint_one2many2one()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(batch mode)  Single image -&gt; multi-coil data -&gt; single image selfadjoint  <span class="math notranslate nohighlight">\(A^H A\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>set_sense()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(batch mode) Set the coil sensitivities</p></td>
</tr>
<tr class="row-even"><td><p>reset_sense()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(batch mode) Reset the coil sensitivities to ones</p></td>
</tr>
<tr class="row-odd"><td><p>offload()</p></td>
<td><p>×</p></td>
<td><p>✓</p></td>
<td><p>Offload the NUFFT_hsa() to device.</p></td>
</tr>
<tr class="row-even"><td><p>x2xx()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Apply the scaling factor</p></td>
</tr>
<tr class="row-odd"><td><p>xx2k()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Oversampled FFT</p></td>
</tr>
<tr class="row-even"><td><p>k2y()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Interpolation</p></td>
</tr>
<tr class="row-odd"><td><p>k2vec()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>(Normal and batch mode) Reshape the k-space to the vector</p></td>
</tr>
<tr class="row-even"><td><p>vec2y()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>(Normal and batch mode) Multiply the vector to generate the data</p></td>
</tr>
<tr class="row-odd"><td><p>vec2k()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>(Normal and batch mode) Reshape the vector to k-space</p></td>
</tr>
<tr class="row-even"><td><p>y2vec()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>(Normal and batch mode) Multiply the data to get the vector</p></td>
</tr>
<tr class="row-odd"><td><p>y2k()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Adjoint of k2y()</p></td>
</tr>
<tr class="row-even"><td><p>k2xx()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Inverse FFT (excessive parts are cropped)</p></td>
</tr>
<tr class="row-odd"><td><p>xx2x()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Apply the scaling factor</p></td>
</tr>
<tr class="row-even"><td><p>_precompute</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(Normal and batch mode) Apply the scaling factor</p></td>
</tr>
</tbody>
</table>
<div class="section" id="parameters-of-pynufft">
<h4>Parameters of PyNUFFT<a class="headerlink" href="#parameters-of-pynufft" title="Permalink to this headline">¶</a></h4>
<p>Below we summarize the required variables in <a class="reference internal" href="#parameter-table"><span class="std std-numref">Table 2</span></a></p>
<span id="parameter-table"></span><table class="colwidths-given docutils align-center" id="id2">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Parameters of the plan() method</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>NUFFT_cpu</p></th>
<th class="head"><p>NUFFT_hsa</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>om (Numpy Array)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Non-Cartesian coordinates (M, dim)</p></td>
</tr>
<tr class="row-odd"><td><p>Nd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the image grid</p></td>
</tr>
<tr class="row-even"><td><p>Kd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the oversampled Fourier grid</p></td>
</tr>
<tr class="row-odd"><td><p>Jd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the interpolator</p></td>
</tr>
<tr class="row-even"><td><p>ft_axes (tuple)</p></td>
<td><p>optional</p></td>
<td><p>optional</p></td>
<td><p>FFT on the given axes (default = None (all axes))</p></td>
</tr>
<tr class="row-odd"><td><p>batch (int)</p></td>
<td><p>optional</p></td>
<td><p>optional</p></td>
<td><p>Batch NUFFT (default = None)</p></td>
</tr>
<tr class="row-even"><td><p>radix (int)</p></td>
<td><p>×</p></td>
<td><p>optional</p></td>
<td><p>radix (default = 1)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<span id="document-tutor/init"></span><div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-tutor/basic_use"></span><div class="section" id="basic-use-of-pynufft">
<h3>Basic use of PyNUFFT<a class="headerlink" href="#basic-use-of-pynufft" title="Permalink to this headline">¶</a></h3>
<p>This section navigates you through the basic use of PyNUFFT.</p>
<div class="section" id="initiating-a-pynufft-object">
<h4>Initiating a PyNUFFT object<a class="headerlink" href="#initiating-a-pynufft-object" title="Permalink to this headline">¶</a></h4>
<p>We can initiate a PyNUFFT by importing the NUFFT_cpu object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># import NUFFT_cpu class</span>
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>

<span class="c1"># Initiate the NufftObj object</span>
<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
</pre></div>
</div>
<p>The NufftObj object has been created but at this point it is still empty.</p>
<p>Now we have to plan the NufftObj by calling the plan() method.
The plan() method takes the input variables and plans for the object.
Now we can plan for the NufftObj object given the non-Cartesian coordinates (om).</p>
<p>In the following code we have 100 random samples spreading across the 2D plane.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># generating 2D random coordinates</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="plan-for-the-nufft-object">
<h4>Plan for the NUFFT object<a class="headerlink" href="#plan-for-the-nufft-object" title="Permalink to this headline">¶</a></h4>
<p>Now we call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>See :py:class: <cite>pynufft.NUFFT_cpu</cite> and  :py:class: <cite>pynufft.NUFFT_hsa</cite></p>
</div>
<div class="section" id="forward-nufft">
<h4>Forward NUFFT<a class="headerlink" href="#forward-nufft" title="Permalink to this headline">¶</a></h4>
<p>The forward NUFFT transforms the image into non-Cartesian samples.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>If batch = None, the image.shape is equal to Nd. The returned y has a shape which is equal to (M, )</p>
<p>If a batch number is provided, the image.shape is equal to Nd + (batch, ). The returned y has a shape which is equal to (M, batch)</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">pynufft.NUFFT_cpu.forward()</span></code> :py:func: <cite>pynufft.NUFFT_hsa.forward</cite></p>
</div>
<div class="section" id="adjoint-nufft">
<h4>Adjoint NUFFT<a class="headerlink" href="#adjoint-nufft" title="Permalink to this headline">¶</a></h4>
<p>The adjoint NUFFT transforms the non-Cartesian samples into the image</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>If batch = None, y has a shape which is equal to (M, ). The returned image.shape is equal to Nd.</p>
<p>If a batch number is provided, y has a shape which is equal to (M, batch). The returned image.shape is equal to Nd + (batch, ).</p>
</div>
</div>
<span id="document-tutor/example"></span><div class="section" id="the-1d-example">
<h3>The 1D example<a class="headerlink" href="#the-1d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span><span class="p">,</span> <span class="n">NUFFT_hsa</span>
</pre></div>
</div>
<p>Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Planning</strong></p>
<p>The <span class="math notranslate nohighlight">\(M\)</span> locations of the non-uniform samples (<span class="math notranslate nohighlight">\(om\)</span>) must be provided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1512</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># om is an M x 1 ndarray: locations of M points. *om* is normalized between [-pi, pi]</span>
<span class="c1"># Here M = 1512</span>
</pre></div>
</div>
<p>In addition, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>) are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</pre></div>
</div>
<p>Now provide NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. Continue with an example.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="n">time_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">)</span>
<span class="n">time_data</span><span class="p">[</span><span class="mi">96</span><span class="p">:</span><span class="mi">128</span><span class="o">+</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This generates a time series <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>.</p>
<div class="figure align-center" id="id1">
<span id="box-function"></span><a class="reference internal image-reference" href="_images/box_function.png"><img alt="_images/box_function.png" src="_images/box_function.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">A box function time series</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nufft_freq_data</span> <span class="o">=</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;imag&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This displays the non-Cartesian spectrum <a class="reference internal" href="#non-cartesian-spectrum"><span class="std std-numref">Fig. 3</span></a>.</p>
<div class="figure align-center" id="id2">
<span id="non-cartesian-spectrum"></span><a class="reference internal image-reference" href="_images/non_Cartesian_spectrum.png"><img alt="_images/non_Cartesian_spectrum.png" src="_images/non_Cartesian_spectrum.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Non-Cartesian spectrum of box function in <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>. Note the non-uniform density.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Signal restoration through “solve()”</strong></p>
<p>The signal can be solved by the solve() method</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">restore_time</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">restore_time1</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">restore_time2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now display the restored signals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">im1</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_data</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">)</span>
<span class="n">im2</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time1</span><span class="p">),</span><span class="s1">&#39;b:&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">)</span>
<span class="n">im3</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time2</span><span class="p">),</span><span class="s1">&#39;k--&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">)</span>
<span class="n">im4</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time</span><span class="p">),</span><span class="s1">&#39;r:&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;conjugate_gradient_method&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">im3</span><span class="p">,</span><span class="n">im4</span><span class="p">])</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center" id="id3">
<span id="solve"></span><a class="reference internal image-reference" href="_images/script_1D_solve.png"><img alt="_images/script_1D_solve.png" src="_images/script_1D_solve.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Signals restored by “solve()”. L1TVOLS and L1TVOLS are close to <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>, whereas cg is subject to distortion.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The complete code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> 
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
    
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span><span class="p">,</span> <span class="n">NUFFT_hsa</span>


<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1512</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 
<span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,)</span> <span class="c1"># time grid, tuple</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,)</span> <span class="c1"># frequency grid, tuple</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,)</span> <span class="c1"># interpolator </span>

<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>

<span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">time_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">)</span>
<span class="n">time_data</span><span class="p">[</span><span class="mi">64</span><span class="p">:</span><span class="mi">192</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">nufft_freq_data</span> <span class="o">=</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;imag&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">restore_time</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">restore_time1</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">restore_time2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">im1</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_data</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">)</span>
<span class="n">im2</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time1</span><span class="p">),</span><span class="s1">&#39;b:&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">)</span>
<span class="n">im3</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time2</span><span class="p">),</span><span class="s1">&#39;k--&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">)</span>
<span class="n">im4</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time</span><span class="p">),</span><span class="s1">&#39;r:&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;conjugate_gradient_method&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">im3</span><span class="p">,</span><span class="n">im4</span><span class="p">])</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


</pre></div>
</div>
</div>
<span id="document-tutor/more2D"></span><div class="section" id="the-2d-example">
<h3>The 2D example<a class="headerlink" href="#the-2d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module and other packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>
</pre></div>
</div>
<p><strong>Loading the X-Y locations(“om”)</strong></p>
<p>It requires the x-y coordinates of <span class="math notranslate nohighlight">\(M\)</span> points to plan NufftObj.</p>
<p>A 2D trajectory from my PROPELLER MRI research is provided in the pynufft package.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="o">+</span><span class="s1">&#39;om2D.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(M\)</span> locations of non-uniform samples (<span class="math notranslate nohighlight">\(om\)</span>) forms an M x 2 numpy.ndarray</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="p">)</span>

<span class="p">[[</span><span class="o">-</span><span class="mf">3.12932086</span>  <span class="mf">0.28225246</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.1047771</span>   <span class="mf">0.28225246</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.08023357</span>  <span class="mf">0.28225246</span><span class="p">]</span>
 <span class="o">....</span>
<span class="p">[</span><span class="o">-</span><span class="mf">2.99815702</span>  <span class="mf">0.76063216</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.02239823</span>  <span class="mf">0.76447165</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.04663992</span>  <span class="mf">0.76831114</span><span class="p">]]</span>
</pre></div>
</div>
<p>You can see the 2D <span class="math notranslate nohighlight">\(M\)</span> locations by plotting <span class="math notranslate nohighlight">\(x\)</span> versus <span class="math notranslate nohighlight">\(y\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;non-uniform coordinates&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;axis 0&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;axis 1&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>As can be seen in <a class="reference internal" href="#propeller-trajectory"><span class="std std-numref">Fig. 5</span></a>:</p>
<div class="figure align-center" id="id1">
<span id="propeller-trajectory"></span><a class="reference internal image-reference" href="_images/propeller_trajectory.png"><img alt="_images/propeller_trajectory.png" src="_images/propeller_trajectory.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">The 2D PROPELLER trajectory of M points.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Planning</strong>
Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
</pre></div>
</div>
<p>Provided <span class="math notranslate nohighlight">\(om\)</span>, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>  <span class="c1"># image size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting image dimension Nd...&#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>  <span class="c1"># k-space size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting spectrum dimension Kd...&#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># interpolation size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting interpolation size Jd...&#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can plan NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. We continue with an example.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading image...&#39;</span><span class="p">)</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This displays the image <a class="reference internal" href="#d-example-image"><span class="std std-numref">Fig. 6</span></a>.</p>
<div class="figure align-center" id="id2">
<span id="d-example-image"></span><a class="reference internal image-reference" href="_images/2d_example_image.png"><img alt="_images/2d_example_image.png" src="_images/2d_example_image.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">The 2D image from scipy.misc.ascent()</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Image restoration with solve()</strong>:</p>
<p>The image can be restored from non-Cartesian samples y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">image3</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">image4</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">image2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y</span> <span class="p">)</span> <span class="c1"># adjoint</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image (cg)&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image0</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image2</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Adjoint transform&#39;</span><span class="p">)</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TV OLS&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image3</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TV LAD&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image4</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center" id="id3">
<span id="d-restore"></span><a class="reference internal image-reference" href="_images/2D_restoration.png"><img alt="_images/2D_restoration.png" src="_images/2D_restoration.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Image restoration through solve() ‘cg’, ‘L1TVOLS’, ‘L1TVLAD’ and adjoint().</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The spectrum of the restored image:</p>
<div class="figure align-center" id="id4">
<span id="d-spectrum"></span><a class="reference internal image-reference" href="_images/2D_spectrum.png"><img alt="_images/2D_spectrum.png" src="_images/2D_spectrum.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">The spectrum of the restored image solved by cg.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> 
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> 

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>







<span class="c1"># load k-space points</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="o">+</span><span class="s1">&#39;om2D.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>

<span class="c1"># om = numpy.random.randn(120000, 2)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting non-uniform coordinates...&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;non-uniform coordinates&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;axis 0&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;axis 1&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>

<span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>  <span class="c1"># image size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting image dimension Nd...&#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>  <span class="c1"># k-space size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting spectrum dimension Kd...&#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># interpolation size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting interpolation size Jd...&#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">))</span>
<span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading image...&#39;</span><span class="p">)</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting non-uniform data&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y is an (M,) list&#39;</span><span class="p">,</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">image0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image (cg)&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image0</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">image2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y</span> <span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image2</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Adjoint transform&#39;</span><span class="p">)</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">image3</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TV OLS&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image3</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">image4</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TV LAD&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image4</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">shifted_kspectrum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">image0</span><span class="p">)))</span>
<span class="c1">#     print(&#39;getting the k-space spectrum, shape =&#39;,shifted_kspectrum.shape)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Showing the shifted k-space spectrum&#39;</span><span class="p">)</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span> <span class="n">shifted_kspectrum</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="mi">100</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;shifted k-space spectrum&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">W0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">st</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">],</span> <span class="p">))</span>


<span class="c1"># W_x = NufftObj.xx2k( NufftObj.adjoint(NufftObj.forward(NufftObj.k2xx(W0))))</span>
<span class="c1"># W_y =  NufftObj.xx2k(NufftObj.x2xx(NufftObj.adjoint(NufftObj.k2y(W0))))</span>
<span class="n">W</span> <span class="o">=</span>  <span class="n">NufftObj</span><span class="o">.</span><span class="n">xx2k</span><span class="p">(</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">W0</span><span class="p">))</span>

<span class="c1"># W =   NufftObj.y2k(W0)</span>
<span class="c1"># matplotlib.pyplot.subplot(1,)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">((</span><span class="n">W</span><span class="o">*</span><span class="n">W</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ueckers inverse function (real)&#39;</span><span class="p">)</span>
<span class="c1"># matplotlib.pyplot.subplot(1,2,2)</span>
<span class="c1"># matplotlib.pyplot.imshow(W.imag)</span>
<span class="c1"># matplotlib.pyplot.title(&#39;Ueckers inverse function (imaginary)&#39;)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">p0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">k2xx</span><span class="p">((</span><span class="n">W</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">*</span><span class="n">W</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">*</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">xx2k</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error between Toeplitz and Inverse reconstruction&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span><span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p0</span><span class="p">))</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">p0</span> <span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Toeplitz&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ueckers inverse function&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span><span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Difference&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</pre></div>
</div>
</div>
<span id="document-tutor/more3D"></span><div class="section" id="a-3d-example">
<h3>A 3D example<a class="headerlink" href="#a-3d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module and other packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>
</pre></div>
</div>
<p><strong>Planning</strong></p>
<p>Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span><span class="p">,</span> <span class="n">NUFFT_hsa</span>
<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
</pre></div>
</div>
<p>Provided <span class="math notranslate nohighlight">\(om\)</span>, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>) are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="c1"># time grid, tuple</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="c1"># frequency grid, tuple</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># interpolator</span>
<span class="c1">#     om=       numpy.load(DATA_PATH+&#39;om3D.npz&#39;)[&#39;arr_0&#39;]</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">15120</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can plan NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. Continue with an example, as follows.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span> <span class="o">+</span><span class="s1">&#39;phantom_3D_128_128_128.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">special_license</span><span class="p">)</span>
</pre></div>
</div>
<p>This displays the image <a class="reference internal" href="#d-example-image"><span class="std std-numref">Fig. 9</span></a>.</p>
<div class="figure align-center" id="id1">
<span id="d-example-image"></span><a class="reference internal image-reference" href="_images/3D_phantom1.png"><img alt="_images/3D_phantom1.png" src="_images/3D_phantom1.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">The 3D phantom</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Image restoration with solve()</strong>:</p>
<p>The image can be restored from non-Cartesian samples y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">restore_image</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kspace</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

<span class="n">restore_image1</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kspace</span><span class="p">,</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1">#</span>
<span class="n">restore_image2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kspace</span><span class="p">,</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;original&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">restore_image1</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TVLAD&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">restore_image2</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">restore_image</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;CG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id2">
<span id="d-restore"></span><a class="reference internal image-reference" href="_images/3D_restore1.png"><img alt="_images/3D_restore1.png" src="_images/3D_restore1.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Image restoration using’cg’, ‘L1TVOLS’, ‘L1TVLAD’.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">special_license</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">The license of the 3D Shepp-Logan phantom:</span>
<span class="s1">Copyright (c) 2006, Matthias Schabel </span>
<span class="s1">All rights reserved.</span>

<span class="s1">Redistribution and use in source and binary forms, with or without </span>
<span class="s1">modification, are permitted provided that the following conditions are </span>
<span class="s1">met:</span>

<span class="s1">* Redistributions of source code must retain the above copyright </span>
<span class="s1">notice, this list of conditions and the following disclaimer. </span>
<span class="s1">* Redistributions in binary form must reproduce the above copyright </span>
<span class="s1">notice, this list of conditions and the following disclaimer in </span>
<span class="s1">the documentation and/or other materials provided with the distribution </span>
<span class="s1">* Neither the name of the University of Utah Department of Radiology nor the names </span>
<span class="s1">of its contributors may be used to endorse or promote products derived </span>
<span class="s1">from this software without specific prior written permission.</span>

<span class="s1">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; </span>
<span class="s1">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE </span>
<span class="s1">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE </span>
<span class="s1">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE </span>
<span class="s1">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR </span>
<span class="s1">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF </span>
<span class="s1">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </span>
<span class="s1">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </span>
<span class="s1">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) </span>
<span class="s1">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE </span>
<span class="s1">POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">numpy</span> 
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">gray</span>
<span class="k">def</span> <span class="nf">indxmap_diff</span><span class="p">(</span><span class="n">Nd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preindixing for rapid image gradient ()</span>
<span class="sd">    </span>
<span class="sd">    Diff(x) = x.flat[d_indx[0]] - x.flat</span>
<span class="sd">    </span>
<span class="sd">    Diff_t(x) =  x.flat[dt_indx[0]] - x.flat</span>
<span class="sd">                            </span>
<span class="sd">    :param Nd: the dimension of the image</span>
<span class="sd">    :type Nd: tuple with integers</span>
<span class="sd">    :returns d_indx: image gradient</span>
<span class="sd">    :returns  dt_indx:  the transpose of the image gradient </span>
<span class="sd">    :rtype: d_indx: lists with numpy ndarray</span>
<span class="sd">    :rtype: dt_indx: lists with numpy ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">Ndprod</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ndprod</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mylist</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
    <span class="n">d_indx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dt_indx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndims</span><span class="p">):</span>
        <span class="n">d_indx</span> <span class="o">=</span> <span class="n">d_indx</span> <span class="o">+</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>   <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>  <span class="n">mylist</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span> <span class="p">,</span> <span class="n">pp</span>  <span class="p">),</span> <span class="p">(</span><span class="n">Ndprod</span><span class="p">,)</span>  <span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="p">,]</span>
        <span class="n">dt_indx</span> <span class="o">=</span> <span class="n">dt_indx</span> <span class="o">+</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>   <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>  <span class="n">mylist</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="n">pp</span>  <span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">Ndprod</span><span class="p">,)</span> <span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="p">,]</span>

    <span class="k">return</span> <span class="n">d_indx</span><span class="p">,</span>  <span class="n">dt_indx</span>  
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="k">def</span> <span class="nf">gradient_class</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">d_indx</span><span class="p">,</span> <span class="n">dt_indx</span> <span class="o">=</span> <span class="n">indxmap_diff</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),))</span>
    
    <span class="n">row_ind</span> <span class="o">=</span> <span class="n">d_indx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">col_ind</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> 
    <span class="n">G</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span> <span class="n">data</span><span class="p">,</span> 
                                            <span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span>
                                 <span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">-</span> <span class="n">I</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">G</span>
<span class="k">def</span> <span class="nf">gradient_class2</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">d_indx</span><span class="p">,</span> <span class="n">dt_indx</span> <span class="o">=</span> <span class="n">indxmap_diff</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),))</span>
    
    <span class="n">row_ind</span> <span class="o">=</span> <span class="n">dt_indx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">col_ind</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> 
    <span class="n">G</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span> <span class="n">data</span><span class="p">,</span> 
                                            <span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">))</span>
                                 <span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">-</span> <span class="n">I</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">G</span>
<span class="k">def</span> <span class="nf">GBPDNA_old</span><span class="p">(</span><span class="n">nufft</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GBPDNA: test 3D total variation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pynufft.src._helper.helper</span> <span class="k">as</span> <span class="nn">helper</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gy</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">nufft</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">nufft</span><span class="o">.</span><span class="n">thr</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nufft</span><span class="o">.</span><span class="n">st</span><span class="p">[</span><span class="s1">&#39;Nd&#39;</span><span class="p">])))</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">y2</span>
    
    <span class="k">def</span> <span class="nf">AH</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">nufft</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">nufft</span><span class="o">.</span><span class="n">thr</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">py</span><span class="p">))</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x2</span>    
    
    
    <span class="n">Nd</span> <span class="o">=</span> <span class="n">nufft</span><span class="o">.</span><span class="n">st</span><span class="p">[</span><span class="s1">&#39;Nd&#39;</span><span class="p">]</span>
    <span class="n">Gx</span> <span class="o">=</span> <span class="n">gradient_class</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Gy</span> <span class="o">=</span> <span class="n">gradient_class</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Gz</span> <span class="o">=</span> <span class="n">gradient_class</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">Gx2</span> <span class="o">=</span> <span class="n">gradient_class2</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Gy2</span> <span class="o">=</span> <span class="n">gradient_class2</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Gz2</span> <span class="o">=</span> <span class="n">gradient_class2</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">M</span> <span class="o">=</span> <span class="n">nufft</span><span class="o">.</span><span class="n">st</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">AH</span><span class="p">((</span><span class="n">v</span><span class="p">)))</span>
        <span class="n">lab</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">tau_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">lab</span><span class="o">.</span><span class="n">real</span>
    <span class="c1">#     print(lab, tau_1)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">v</span><span class="o">=</span> <span class="n">w</span>
    <span class="n">v</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">),)</span>

    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">Gx</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Gx</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">lab</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">tau_2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">v</span><span class="o">=</span> <span class="n">w</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tau_1 = &quot;</span><span class="p">,</span> <span class="n">tau_1</span><span class="p">)</span>   
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tau_2 = &quot;</span><span class="p">,</span> <span class="n">tau_2</span><span class="p">)</span>
<span class="c1">#     tau_1 = 0.1*tau_1</span>
    <span class="n">tau_2</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">tau_2</span>
<span class="c1">#     tau_2 *= 3</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.001</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">AH</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="o">...</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mu=&quot;</span><span class="p">,</span><span class="n">mu</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">P_lambda</span><span class="p">(</span><span class="n">w_i</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">tau_1</span><span class="p">):</span>
        <span class="n">w_abs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span>
    <span class="c1">#     print(w_abs.shape)</span>
    <span class="c1">#     print(w_iw_abs.shape)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">((</span><span class="n">w_i</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">w_abs</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">))</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">tau_1</span>
        
        <span class="n">indx</span><span class="o">=</span> <span class="n">w_abs</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">tau_1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span><span class="n">w_i</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">def</span> <span class="nf">Q_f_eps</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="n">v_f</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">f</span>
        <span class="n">v_f_abs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_f</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">eps</span><span class="o">*</span> <span class="n">v_f</span><span class="o">/</span><span class="n">v_f_abs</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_f_abs</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">u_bold_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">v_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,)</span>
    <span class="n">z_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,)</span>
    <span class="n">w_kx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">w_ky</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">w_kz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
<span class="c1">#     w_kx2 = numpy.zeros(N,)</span>
<span class="c1">#     w_ky2 = numpy.zeros(N,)</span>
<span class="c1">#     w_kz2 = numpy.zeros(N,)</span>
    
    <span class="n">hx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">hy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">hz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">hx2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">hy2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="n">hz2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    
    <span class="n">tmp_f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,)</span>
    
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-16</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">):</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
        <span class="n">tmp_u</span><span class="o">=</span> <span class="n">u_bold_k</span> <span class="o">-</span> <span class="n">tau_1</span> <span class="o">*</span> <span class="n">AH</span><span class="p">(</span><span class="n">v_k</span> <span class="o">+</span> <span class="n">tmp_f</span><span class="o">-</span> <span class="n">z_k</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
        
        <span class="n">u_bar_kp1</span> <span class="o">=</span> <span class="n">tmp_u</span>   <span class="o">-</span>    <span class="n">tau_1</span> <span class="o">*</span><span class="p">(</span> <span class="n">Gx</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_kx</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gy</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_ky</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gz</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_kz</span><span class="p">)</span> <span class="p">)</span>
<span class="c1">#                                           Gx2.getH().dot(w_kx2) + Gy2.getH().dot(w_ky2) + Gz2.getH().dot(w_kz2) ) </span>
        
    <span class="c1">#     sx = Gx.dot(u_bar_kp1)</span>
    <span class="c1">#     sy = Gy.dot(u_bar_kp1)</span>
    <span class="c1">#     s = (sx**2 + sy**2)**0.5</span>
          
        <span class="n">w_kp1x</span> <span class="o">=</span> <span class="n">P_lambda</span><span class="p">(</span><span class="n">w_kx</span> <span class="o">+</span> <span class="p">(</span><span class="n">tau_2</span><span class="o">/</span><span class="n">tau_1</span><span class="p">)</span><span class="o">*</span><span class="n">Gx</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_bar_kp1</span><span class="p">),</span> <span class="n">mu</span><span class="p">,</span> <span class="n">tau_1</span><span class="p">)</span>
        <span class="n">w_kp1y</span> <span class="o">=</span> <span class="n">P_lambda</span><span class="p">(</span><span class="n">w_ky</span><span class="o">+</span> <span class="p">(</span><span class="n">tau_2</span><span class="o">/</span><span class="n">tau_1</span><span class="p">)</span><span class="o">*</span><span class="n">Gy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_bar_kp1</span><span class="p">),</span> <span class="n">mu</span><span class="p">,</span> <span class="n">tau_1</span><span class="p">)</span>
        <span class="n">w_kp1z</span> <span class="o">=</span> <span class="n">P_lambda</span><span class="p">(</span><span class="n">w_kz</span><span class="o">+</span> <span class="p">(</span><span class="n">tau_2</span><span class="o">/</span><span class="n">tau_1</span><span class="p">)</span><span class="o">*</span><span class="n">Gz</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_bar_kp1</span><span class="p">),</span> <span class="n">mu</span><span class="p">,</span> <span class="n">tau_1</span><span class="p">)</span>
<span class="c1">#         w_kp1x2 = P_lambda(w_kx2+ (tau_2/tau_1)*Gx2.dot(u_bar_kp1), mu, tau_1)</span>
<span class="c1">#         w_kp1y2 = P_lambda(w_ky2+ (tau_2/tau_1)*Gy2.dot(u_bar_kp1), mu, tau_1)</span>
<span class="c1">#         w_kp1z2 = P_lambda(w_kz2+ (tau_2/tau_1)*Gz2.dot(u_bar_kp1), mu, tau_1)</span>
        
    <span class="c1">#     hx = (sx+eps)/(s+eps)*Gx.getH().dot(w_kp1)</span>
    <span class="c1">#     hy = (sy+eps)/(s+eps)*Gy.getH().dot(w_kp1)</span>
        
        <span class="n">u_bold_kp1</span> <span class="o">=</span> <span class="n">tmp_u</span>   <span class="o">-</span>   <span class="n">tau_1</span> <span class="o">*</span><span class="p">(</span> <span class="n">Gx</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_kp1x</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gy</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_kp1y</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gz</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_kp1z</span><span class="p">))</span>
<span class="c1">#                                           Gx2.getH().dot(w_kp1x2) + Gy2.getH().dot(w_kp1y2) + Gz2.getH().dot(w_kp1z2)) </span>
        
        <span class="n">tmp_f</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="n">u_bold_kp1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">))</span>
        <span class="n">z_kp1</span> <span class="o">=</span> <span class="n">Q_f_eps</span><span class="p">(</span><span class="n">tmp_f</span> <span class="o">+</span> <span class="n">v_k</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">v_kp1</span> <span class="o">=</span> <span class="n">v_k</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">tmp_f</span>    <span class="o">-</span>   <span class="n">z_kp1</span><span class="p">)</span>
        <span class="n">w_kx</span> <span class="o">=</span> <span class="n">w_kp1x</span>
        <span class="n">w_ky</span> <span class="o">=</span> <span class="n">w_kp1y</span>
        <span class="n">w_kz</span> <span class="o">=</span> <span class="n">w_kp1z</span>
<span class="c1">#         w_kx2 = w_kp1x2</span>
<span class="c1">#         w_ky2 = w_kp1y2</span>
<span class="c1">#         w_kz2 = w_kp1z2</span>
        
        <span class="n">u_bold_k</span> <span class="o">=</span> <span class="n">u_bold_kp1</span>
        <span class="n">v_k</span> <span class="o">=</span> <span class="n">v_kp1</span>
        <span class="n">z_k</span> <span class="o">=</span> <span class="n">z_kp1</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u_bar_kp1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>


        
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>   
<span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span> <span class="o">+</span><span class="s1">&#39;phantom_3D_128_128_128.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span><span class="c1">#[0::2, 0::2, 0::2]</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

<span class="c1"># image = numpy.load(&#39;/home/sram/UCL/DATA/G/2 McwBra DICOM/CScontNoECG_DICOM/3D_volume.npz&#39;)[&#39;arr_0&#39;]</span>
<span class="c1"># image = image/numpy.max(abs(image.ravel()))</span>
<span class="c1"># image = image[32:32+128, 32:32+128,12:12+64]</span>
<span class="c1"># image = numpy.abs(image)</span>
<span class="c1"># print(special_license)</span>

<span class="c1"># pyplot.imshow(numpy.abs(image[:,:,64]), label=&#39;original signal&#39;,cmap=gray)</span>
<span class="c1"># pyplot.show()</span>

<span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="c1"># time grid, tuple</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span> <span class="c1"># frequency grid, tuple</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="c1"># interpolator </span>
<span class="n">mid_slice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Nd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#     om=       numpy.load(DATA_PATH+&#39;om3D.npz&#39;)[&#39;arr_0&#39;]</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">5e+5</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span><span class="p">,</span> <span class="n">NUFFT_hsa</span><span class="p">,</span> <span class="n">NUFFT_hsa_legacy</span>
<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="n">API</span> <span class="o">=</span> <span class="s1">&#39;ocl&#39;</span><span class="p">,</span>   <span class="n">platform_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>


<span class="c1"># NufftObj.offload(API = &#39;cuda&#39;,   platform_number = 0, device_number = 0)</span>
<span class="n">gx</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">thr</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">))</span>
<span class="n">gy</span> <span class="o">=</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span> 
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">restore_x2</span> <span class="o">=</span> <span class="n">GBPDNA_old</span><span class="p">(</span><span class="n">NufftObj</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">restore_x</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">gy</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;GBPDNA time = &quot;</span><span class="p">,</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CG time = &quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span>

<span class="c1">#restore_image1 = NufftObj.solve(kspace,&#39;L1TVLAD&#39;, maxiter=300,rho=0.1)</span>
<span class="c1"># </span>
<span class="c1"># restore_x2 = NufftObj.solve(gy,&#39;L1TVOLS&#39;, maxiter=100,rho=0.2)</span>
<span class="c1"># tau_1 = 1</span>
<span class="c1"># tau_2 = 0.1</span>


<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">gx</span><span class="o">.</span><span class="n">get</span><span class="p">()[:,:,</span><span class="n">mid_slice</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;original&#39;</span><span class="p">)</span>    
<span class="c1">#pyplot.subplot(2,2,2)</span>
<span class="c1">#pyplot.imshow(numpy.real(restore_image1[:,:,32]), label=&#39;L1TVLAD&#39;,cmap=gray)</span>
<span class="c1">#pyplot.title(&#39;L1TVLAD&#39;)</span>

<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_x2</span><span class="p">[:,:,</span><span class="n">mid_slice</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;GBPDNA (500 iterations)&#39;</span><span class="p">)</span>
    

<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


</pre></div>
</div>
</div>
</div>
</div>
<span id="document-manu/init"></span><div class="section" id="manual">
<h2>Manual<a class="headerlink" href="#manual" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-manu/NUFFT_cpu"></span><div class="section" id="nufft-cpu">
<h3>NUFFT_cpu<a class="headerlink" href="#nufft-cpu" title="Permalink to this headline">¶</a></h3>
<p><strong>The NUFFT_cpu class</strong></p>
<p>The NUFFT_cpu class encapsulates the NUFFT function using the Numpy/Scipy environment.
This allows portability so the NUFFT_cpu() can be easily ported to Windows and Linux.
Users can install their favourite Python distribution.
So far, I have tested Anaconda, intel-python, intel-numpy and open-source python.</p>
<p>However, the performance of NUFFT_cpu is therefore impacted by the Numpy implementation.</p>
<p>Defining the equispaced to non-Cartesian transform as  operator <span class="math notranslate nohighlight">\(A\)</span>, the
NUFFT_cpu class provides the following methods:</p>
<ul class="simple">
<li><dl class="simple">
<dt>forward() method computes the single-coil to single-coil, or multi-coil to</dt><dd><p>multi-coil (batch mode) forward operation <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>adjoint() method computes the single-coil to single-coil, or multi-coil to</dt><dd><p>multi-coil  (batch mode) adjoint operation  <span class="math notranslate nohighlight">\(A^H\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selfadjoint() method computes the single-coil to single-coil, or multi-coil</dt><dd><p>to multi-coil (batch mode) selfadjoint operation <span class="math notranslate nohighlight">\(A^H A\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>forward_one2many() method computes the single-coil to multi-coil forward</dt><dd><p>operation <span class="math notranslate nohighlight">\(A\)</span> in batch mode. The single-coil image is copied to
multi-coil images before transform. If set_sense() is called first,
multi-coil images will be implicitly multiplied by the coil
sensitivities before transform. If set_sense() is never called,
multi-coil images will not be changed by the coil sensitivities before
transform.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>adjoint_many2one() method computes the multi-coil to single-coil adjoint</dt><dd><p>operation  <span class="math notranslate nohighlight">\(A^H\)</span> in batch mode.
The final reduction will divide the summed image by the number of
coils. If set_sense() is called first, multi-coil images will be
implicitly multiplied by the conjugate of coil sensitivities before
reduction. If set_sense() is never called, multi-coil images will not
be changed by the coil sensitivities before reduction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selfadjoint_one2many2one () method computes the single-coil to single-coil</dt><dd><p>selfadjoint operation <span class="math notranslate nohighlight">\(A^H A\)</span> in batch mode.
It connects forward_one2many() and adjoint_many2one() methods.
If set_sense() is called first, coil sensitivities and the conjugate
are used during forward_one2many() and adjoint_many2one().</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>solve() method links many solvers in pynufft.linalg.solver_cpu,</dt><dd><p>which is based on the solvers of scipy.sparse.linalg.cg,
scipy.sparse.linalg. ‘lsqr’, ‘dc’, ‘bicg’, ‘bicgstab’, ‘cg’,
‘gmres’, ‘lgmres’</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p>NUFFT_cpu.ndims: the dimension</p></li>
<li><p>NUFFT_cpu.ft_axes: the axes where the FFT takes place</p></li>
<li><dl class="simple">
<dt>NUFFT_cpu.parallel_flag: 1 for parallel transform.</dt><dd><p>0 for single channel.
If 1, the additional axis is batch.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NUFFT_cpu.batch: internal attribute saving the number of channels.</dt><dd><p>If parallel_flag is 0, the batch is 1.
Otherwise, the batch must be given explictly during planning.</p>
</dd>
</dl>
</li>
<li><p>NUFFT_cpu.Nd: Tuple, the dimensions of the image</p></li>
<li><p>NUFFT_cpu.Kd: Tuple, the dimensions of the oversampled k-space</p></li>
</ul>
<p><strong>The life-cycle of an NUFFT_cpu object</strong></p>
<p>NUFFT_cpu employs the plan-execution two-stage model.
This can maximize the runtime speed, at the cost of the extra precomputation times and extra memory.</p>
<p>Instantiating an NUFFT_cpu instance defines only some instance attributes. Instance attributes will be replaced later once the method plan() is called.</p>
<p>Then the plan() method will call the helper.plan() function,
which constructs the scaling factor and the interpolator.
The interpolator is precomputed and stored in the Compressed Sparse Row (CSR) format.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html">scipy.sparse.csr_matrix</a> and
<a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)">CSR in Wikipedia</a>.</p>
<p>Once the object has been planned, the forward() and adjoint() methods reuse the saved scaling factors and interpolators.</p>
</div>
<span id="document-manu/NUFFT_hsa"></span><div class="section" id="nufft-hsa">
<h3>NUFFT_hsa<a class="headerlink" href="#nufft-hsa" title="Permalink to this headline">¶</a></h3>
<p><strong>The NUFFT_hsa class</strong></p>
<p>Defining the equispaced to non-Cartesian transform as  operator <span class="math notranslate nohighlight">\(A\)</span>, the
NUFFT_hsa class provides the following methods:</p>
<ul class="simple">
<li><dl class="simple">
<dt>forward() method computes the single-coil to single-coil, or multi-coil to</dt><dd><p>multi-coil (batch mode) forward operation <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>adjoint() method computes the single-coil to single-coil, or multi-coil to</dt><dd><p>multi-coil  (batch mode) adjoint operation  <span class="math notranslate nohighlight">\(A^H\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selfadjoint() method computes the single-coil to single-coil, or multi-coil</dt><dd><p>to multi-coil (batch mode) selfadjoint operation <span class="math notranslate nohighlight">\(A^H A\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>forward_one2many() method computes the single-coil to multi-coil forward</dt><dd><p>operation <span class="math notranslate nohighlight">\(A\)</span> in batch mode. The single-coil image is copied to
multi-coil images before transform. If set_sense() is called first,
multi-coil images will be implicitly multiplied by the coil
sensitivities before transform. If set_sense() is never called,
multi-coil images will not be changed by the coil sensitivities before
transform.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>adjoint_many2one() method computes the multi-coil to single-coil adjoint</dt><dd><p>operation  <span class="math notranslate nohighlight">\(A^H\)</span> in batch mode.
The final reduction will divide the summed image by the number of
coils. If set_sense() is called first, multi-coil images will be
implicitly multiplied by the conjugate of coil sensitivities before
reduction. If set_sense() is never called, multi-coil images will not
be changed by the coil sensitivities before reduction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selfadjoint_one2many2one () method computes the single-coil to single-coil</dt><dd><p>selfadjoint operation <span class="math notranslate nohighlight">\(A^H A\)</span> in batch mode.
It connects forward_one2many() and adjoint_many2one() methods.
If set_sense() is called first, coil sensitivities and the conjugate
are used during forward_one2many() and adjoint_many2one().</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>solve() method links many solvers in pynufft.linalg.solver_cpu,</dt><dd><p>which is based on the solvers of scipy.sparse.linalg.cg,
scipy.sparse.linalg.’lsqr’, ‘dc’, ‘bicg’, ‘bicgstab’, ‘cg’,
‘gmres’, ‘lgmres’</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p>NUFFT_hsa.ndims: the dimension</p></li>
<li><p>NUFFT_hsa.ft_axes: the axes where the FFT takes place</p></li>
<li><dl class="simple">
<dt>NUFFT_hsa.parallel_flag: 1 for parallel transform.</dt><dd><p>0 for single channel.
If 1, the additional axis is batch.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NUFFT_hsa.batch: internal attribute saving the number of channels.</dt><dd><p>If parallel_flag is 0, the batch is 1.
Otherwise, the batch must be given explicitly during planning.</p>
</dd>
</dl>
</li>
<li><p>NUFFT_hsa.Nd: Tuple, the dimensions of the image</p></li>
<li><p>NUFFT_hsa.Kd: Tuple, the dimensions of oversampled k-space</p></li>
</ul>
<p><strong>Acceleration on PyCUDA/PyOpenCL</strong></p>
<p>The NUFFT_hsa was designed to accelerate the NUFFT function
on the multi-core CPU and GPU, using PyOpenCL and PyCUDA backends.
This was made possible by using Reikna meta-package.</p>
<p>If multiple NUFFT_hsa objects are created with the PyCUDA backend,
each call can be executed only after the  context has ‘popped up’. This is
achieved by the decorator function push_cuda_context():
calling NUFFT_hsa methods will trigger the decorator and get the context popped up.
However, PyOpenCL has no such restriction
and the call will automatically bypass the decorator for the NUFFT_hsa
with the PyOpenCL backend.</p>
<p>Different objects can be constructed on different PyCUDA and PyOpenCL backends.</p>
<p><strong>The life-cycle of the PyNUFFT_hsa object</strong></p>
<p>NUFFT_hsa employs the plan-execution two-stage model.
This can maximize the runtime speed, at the cost of the extra precomputation times and extra memory.</p>
<p>Instantiating an NUFFT_hsa instance also initiates the context and defines some instance attributes.
The context is linked to the accelerator and the kernels are compiled on the chosen device.
Instance attributes will be replaced later when the method plan() is called.</p>
<p>Then the plan() method calls the helper.plan() function,
which constructs the scaling factor and the interpolator.
The interpolator is precomputed and stored as multiple 1D ELLpack (ELL) sparse matrices.
Each ELL matrix preserves the sparse matrix as the data and column indices.
Multi-dimensional interpolators are implemented as a concatenated multiple 1D ELL sparse matrices.
The actual data and column indices are inferred from the meshindex.
At the end of the plan() method, the offload() method transfers the
precomputed arrays to the accelerator.</p>
<p>The run-time computations reuse the saved scaling factors and
interpolators.</p>
</div>
<span id="document-manu/multiple_NUFFT"></span><div class="section" id="multiple-nufft-instances">
<h3>Multiple NUFFT instances<a class="headerlink" href="#multiple-nufft-instances" title="Permalink to this headline">¶</a></h3>
<p>Multiple NUFFT_cpu instances, NUFFT_hsa instances,
or mixed types of instances can exist at the same time.
Each instance has its own memory.
However,  multiple instances  may be penalized by hardware and reduced runtime speed.</p>
<p>Multiple instances can be planned after all the instances have been created.
Alternatively, each instance can be planned immediately after being created.</p>
<p>Note that multiple PyCUDA instances were made possible since 2019.1.1,
by introducing the push_cuda_context() decorating function.
Versions earlier than 2019.1.1 do not support multiple PyCUDA backends.
This is because every call to a CUDA context will require the current
context to pop up to the top of the stack of the contexts.</p>
<p>PyOpenCL does not have the context pop-up issue but please always use the newest version.</p>
<p><strong>Multiple NUFFT_cpu instances</strong></p>
<p>Multiple instances can be planned after all the instances have been created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT_cpu</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="c1"># Create the second NUFFT_cpu</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="c1"># Plan the first instance</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>or each instance can be planned once it has been created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT_cpu</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="c1"># Create the second NUFFT_cpu</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">NufftObj1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">NufftObj2</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Multiple NUFFT_hsa instances</strong></p>
<p>Like NUFFT_cpu, each instance can be planned immediately after being created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT_hsa</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="c1"># Create the second NUFFT_hsa</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">NufftObj1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">NufftObj2</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Mixing cuda and opencl is also possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT_hsa</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="s1">&#39;ocl&#39;</span><span class="p">)</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="c1"># Create the second NUFFT_hsa</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">NufftObj1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">NufftObj2</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="multiprocessing-experimental">
<h3>Multiprocessing (experimental)<a class="headerlink" href="#multiprocessing-experimental" title="Permalink to this headline">¶</a></h3>
<p>The multiprocessing module is the built-in parallel method of C-Python.
PyNUFFT may (experimentally) work together with the multiprocessing
module of Python.</p>
<p>The mutliprocessing module relies on pickle to serialize the data, whereas
the PyCUDA and PyOpenCL contexts are “unpicklable”.
Thus, I found that multiprocessing for PyNUFFT must fulfil the following conditions: (1)
each NUFFT_hsa instance should be created and then executed in a separate process;
(2) any CUDA/PyOpenCL related object cannot be sent or planned in advance, and
(3) taskset should be used to assign a process to a specified CPU core.</p>
<p>It is the user’s responsibility to take care of the hardware (total memory and IO).</p>
<p>One example of working with multiprocessing (mixed CUDA and OpenCL backends) is as follows.
In this example, an “atomic_NUFFT” class is created as a high-level wrapper for the creation and execution of NUFFT_hsa.
This example has only been tested in Linux because parallel computing is highly platform dependent.</p>
</div>
<span id="document-manu/batch_mode"></span><div class="section" id="batched-nufft">
<h3>Batched NUFFT<a class="headerlink" href="#batched-nufft" title="Permalink to this headline">¶</a></h3>
<p>The batch mode NUFFT can compute multiple NUFFTs at the same time.
This relies on the ‘batch’ keyword during the plan() stage.
If the batch is a postive integer, multiple NUFFTs are enclosed
in the instance.
If the batch is not provided (batch=’None’), it regresses to the non-batch mode.
Note the the input data and the output data of different channels are usually different.</p>
<p>In this batch mode, the size of the input array is Nd + (batch, )
and the size of the output array is (M, batch).
In the non-batch mode, the size of the input array is Nd, and the size of the output array is (M, ).</p>
<p>Warning: the maximum size of a single NUFFT instance is still restricted by the Max memory allocation.
OpenCL allows a single buffer which is 1/4 of the total memory.</p>
<p>The following example shows the batch mode</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_batch_NUFFT</span><span class="p">():</span>
    
    <span class="kn">import</span> <span class="nn">scipy.misc</span>
    <span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
    
    <span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
    <span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
    
    <span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">#     image = scipy.misc.imresize(image, Nd).astype(numpy.complex64)</span>
    <span class="n">om</span> <span class="o">=</span> <span class="n">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    
    <span class="n">batch</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of samples (M) = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dimension = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nd = &#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Kd = &#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Jd = &#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
     
<span class="c1">#     NufftObj = NUFFT_cpu()</span>
    <span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
    <span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>  <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
    
    <span class="c1"># Now transform 1 image to multiple channels using forward_one2many() method</span>
<span class="c1">#     y = NufftObj.forward_one2many(image) # for NUFFT_cpu()</span>
    <span class="n">multi_image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Nd</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">Nd</span> <span class="o">+</span> <span class="p">(</span><span class="n">batch</span><span class="p">,))</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">multi_image</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span>

<span class="c1">#     y = NufftObj.forward_one2many(image).get() # for NUFFT_hsa()</span>
    
    <span class="c1"># Now reshape the data for IFFT</span>
<span class="c1">#     y2 = y.reshape(Nd + (batch, ), order=&#39;C&#39;) </span>
    
    <span class="c1"># Perform IFFT to check the correctness of the k-space</span>
<span class="c1">#     x2 = numpy.fft.ifftshift(</span>
<span class="c1">#                 numpy.fft.ifftn(</span>
<span class="c1">#                     numpy.fft.ifftshift(y2, axes = (0,1)</span>
<span class="c1">#                     ), axes = (0,1)</span>
<span class="c1">#                 ), axes = (0,1)</span>
<span class="c1">#             )</span>
    
    <span class="n">x2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
    
    
    <span class="c1"># display the result</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span>    <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">pp</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">)</span><span class="c1">#vmin = 0, vmax = 255)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original image&#39;</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pp</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x2</span><span class="p">[:,:,</span><span class="n">pp</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">)</span><span class="c1">#vmin = 0, vmax = 255)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image  of coil &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">#         matplotlib.pyplot.subplot(batch,3,3 + pp*3)</span>
<span class="c1">#         matplotlib.pyplot.imshow(abs(image - x2[:,:,pp]), vmin = 0, vmax = 255)</span>
<span class="c1">#         matplotlib.pyplot.title(&#39;Difference map of coil &#39;+str(pp + 1))</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<span id="document-manu/mcoil"></span><div class="section" id="multi-coil-nufft">
<h3>Multi-coil NUFFT<a class="headerlink" href="#multi-coil-nufft" title="Permalink to this headline">¶</a></h3>
<p>Coil sensitivity profiles can be incorporated into the
NUFFT.  The set_sense() instance method accepts the coil sensitivity profile.
Once the coil sensitivity profile is configured, the forward() method
applies the coil sensitivity profile, while the  adjoint() method
applies the conjugate of the coil sensitivity profile.</p>
<p>The reset_sense() resets the coil sensitivities to one and it returns to batch NUFFT.
If the set_sense() is not called, the default coil sensitivities are all
ones and it is a batch NUFFT.</p>
<p>Both the NUFFT_cpu and NUFFT_hsa instances support the multi-coil mode.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_senselike_NUFFT</span><span class="p">():</span>
    
    <span class="kn">import</span> <span class="nn">scipy.misc</span>
    <span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span><span class="p">,</span> <span class="n">helper</span>
    
    <span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
    <span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
    
    <span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">#     image = scipy.misc.imresize(image, Nd).astype(numpy.complex64)</span>
    <span class="n">om</span> <span class="o">=</span> <span class="n">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    
    <span class="n">batch</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of samples (M) = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dimension = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nd = &#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Kd = &#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Jd = &#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
     
<span class="c1">#     NufftObj = NUFFT_cpu()</span>
    <span class="n">device_list</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">device_list</span><span class="p">()</span>
    <span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">(</span><span class="n">device_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
    
    <span class="c1"># Now create fake coil sensitivity profiles</span>
    <span class="n">sense_array</span> <span class="o">=</span> <span class="n">create_fake_coils</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span>
    
    <span class="c1"># set_sense() method apply the sensitivities to the object</span>
    <span class="n">NufftObj</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">sense_array</span><span class="p">)</span>
    
<span class="c1">#     NufftObj.reset_sense() # reset the coil sensitivity profile</span>
    
    <span class="c1"># Now transform 1 image to multiple channels using forward_one2many() method</span>
<span class="c1">#     y = NufftObj.forward_one2many(image) # for NUFFT_cpu()</span>

<span class="c1">#     multi_image = numpy.broadcast_to(numpy.reshape(image, Nd + (1,)), Nd + (batch,))</span>
<span class="c1">#     y = NufftObj.forward(multi_image).get()</span>

    <span class="n">y0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward_one2many</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="c1"># for NUFFT_hsa()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="c1"># Now reshape the data for IFFT</span>
<span class="c1">#     y2 = y.reshape(Nd +(batch, ) , order=&#39;C&#39;) </span>
<span class="c1">#     </span>
<span class="c1">#     # Perform IFFT to check the correctness of the k-space</span>
<span class="c1">#     x2 = numpy.fft.ifftshift(</span>
<span class="c1">#                 numpy.fft.ifftn(</span>
<span class="c1">#                     numpy.fft.ifftshift(y2, axes = (0,1)</span>
<span class="c1">#                     ), axes = (0,1)</span>
<span class="c1">#                 ), axes = (0,1)</span>
<span class="c1">#             )</span>
    
    <span class="n">x2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
    
    <span class="c1"># display the result</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span>    <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">pp</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original image&#39;</span><span class="p">)</span>
        
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pp</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">sense_array</span><span class="p">[:,:,</span><span class="n">pp</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Simulated coil sensitivity &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span> <span class="o">+</span> <span class="n">pp</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x2</span><span class="p">[:,:,</span><span class="n">pp</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image of coil &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pp</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<span id="document-manu/realistic_om"></span><div class="section" id="k-space-trajectories-om">
<h3>k-Space trajectories (om)<a class="headerlink" href="#k-space-trajectories-om" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cartesian-k-space">
<h4>Cartesian k-space<a class="headerlink" href="#cartesian-k-space" title="Permalink to this headline">¶</a></h4>
<p>This section aims to provide a good example to show that NUFFT can be used to compute many different trajectories, including the Cartesian k-space.</p>
<p>However, Cartesian k-space should mostly be computed by FFT and this section is provided only for testing.</p>
<p>In the example, we generate a PyNUFFT object and make a plan using Cartesian k-space, followed by the NUFFT transform.</p>
<p>The data is created by NUFFT but on the Cartesian grid.</p>
<p>Last the Cartesian data are transformed back to image by IFFT (with two ifftshifts before and after ifftn):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating trajectories for Cartesian k-space</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">):</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span> <span class="c1"># dimension</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dimid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="n">om</span><span class="p">[:,</span> <span class="n">dimid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">dimid</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span><span class="mi">2</span><span class="o">/</span> <span class="n">Nd</span><span class="p">[</span><span class="n">dimid</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">om</span>

<span class="kn">import</span> <span class="nn">scipy.misc</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>


<span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of samples (M) = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dimension = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nd = &#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Kd = &#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Jd = &#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">y2</span><span class="p">)))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original image&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">x2</span><span class="p">),</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Difference map&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>As you can see, the resulting images (<a class="reference internal" href="#fake-cartesian"><span class="std std-numref">Fig. 11</span></a>) confirm that NUFFT + IFFT can restore the original image.</p>
<div class="figure align-center" id="id1">
<span id="fake-cartesian"></span><a class="reference internal image-reference" href="_images/fake_Cartesian.png"><img alt="_images/fake_Cartesian.png" src="_images/fake_Cartesian.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">A Cartesian example generates the contrived Cartesian data using NUFFT, followed by IFFT.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="radial-k-space">
<h4>Radial k-space<a class="headerlink" href="#radial-k-space" title="Permalink to this headline">¶</a></h4>
<p>We can generate the radial spokes on the 2D plane.
Each radial spoke spans the range of  <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> at the angle <span class="math notranslate nohighlight">\(\theta\)</span> and each point is fully determined by the  polar coordinate (R, <span class="math notranslate nohighlight">\(\theta\)</span>).
See <a class="reference internal" href="#radial-spoke"><span class="std std-numref">Fig. 12</span></a> for more information.</p>
<div class="figure align-center" id="id2">
<span id="radial-spoke"></span><a class="reference internal image-reference" href="_images/radial_spoke.png"><img alt="_images/radial_spoke.png" src="_images/radial_spoke.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Illustration of five radial spokes.
Each point of the spoke can be described by the polar coordinate (R, <span class="math notranslate nohighlight">\(\theta\)</span>),
which can be transformed to Cartesian coordinates (R cos(<span class="math notranslate nohighlight">\(\theta\)</span>), R sin(<span class="math notranslate nohighlight">\(\theta\)</span>)).</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>The following code generates 360 radial spokes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># generating 2D radial coordinates</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">spoke_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span> <span class="o">-</span> <span class="mf">256.0</span> <span class="p">)</span><span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span> <span class="mi">256</span>  <span class="c1"># normalized between -pi and pi</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">512</span><span class="o">*</span><span class="mi">360</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


<span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">):</span>
   <span class="n">radian</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span> <span class="mf">360.0</span>
   <span class="n">spoke_x</span> <span class="o">=</span>  <span class="n">spoke_range</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radian</span><span class="p">)</span>
   <span class="n">spoke_y</span> <span class="o">=</span>  <span class="n">spoke_range</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radian</span><span class="p">)</span>
   <span class="n">om</span><span class="p">[</span><span class="mi">512</span><span class="o">*</span><span class="n">angle</span> <span class="p">:</span> <span class="mi">512</span><span class="o">*</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spoke_x</span>
   <span class="n">om</span><span class="p">[</span><span class="mi">512</span><span class="o">*</span><span class="n">angle</span> <span class="p">:</span> <span class="mi">512</span><span class="o">*</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spoke_y</span>


<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">om</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<span id="document-manu/variable_radix"></span><div class="section" id="radix-1-radix-2-and-mixed-radix-nufft-advanced">
<h3>Radix-1, Radix-2 and mixed radix NUFFT (advanced)<a class="headerlink" href="#radix-1-radix-2-and-mixed-radix-nufft-advanced" title="Permalink to this headline">¶</a></h3>
<p>NUFFT_hsa has a feature called radix, which controls how the different dimensions are computed.</p>
</div>
</div>
</div>
<span id="document-API/init"></span><div class="section" id="api-documentation">
<h2>API documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pynufft.linalg"></span><span class="target" id="module-pynufft.linalg.nufft_cpu"></span><div class="section" id="nufft-cpu-class">
<h3>NUFFT CPU class<a class="headerlink" href="#nufft-cpu-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu">
<em class="property">class </em><code class="descclassname">pynufft.linalg.nufft_cpu.</code><code class="descname">NUFFT_cpu</code><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Class NUFFT_cpu</p>
<dl class="attribute">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.Jd">
<code class="descname">Jd</code><em class="property"> = None</em><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.Jd" title="Permalink to this definition">¶</a></dt>
<dd><p>initial value: ()</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python NoneType</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NUFFT: the pynufft_hsa.NUFFT instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NUFFT: the pynufft_hsa.NUFFT class</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu._precompute_sp">
<code class="descname">_precompute_sp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu._precompute_sp" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: Precompute adjoint (gridding) and Toepitz interpolation</dt><dd><p>matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python Nonetype</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self: instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.adjoint">
<code class="descname">adjoint</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> – The input numpy array, with the size of (M,) or (M, batch)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array,
with the size of Nd or Nd + (batch, )</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.adjoint_many2one">
<code class="descname">adjoint_many2one</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.adjoint_many2one" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume y.shape = self.multi_M</p>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.debug">
<code class="descname">debug</code><em class="property"> = None</em><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>initial value: 0</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.forward">
<code class="descname">forward</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with the size of Nd or Nd + (batch,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>y: The output numpy array, with the size of (M,) or (M, batch)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.forward_one2many">
<code class="descname">forward_one2many</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.forward_one2many" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume x.shape = self.Nd</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.k2xx">
<code class="descname">k2xx</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.k2xx" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the inverse FFT and image cropping (which is the reverse of</dt><dd><p>_xx2k() method)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.k2xx_one2one">
<code class="descname">k2xx_one2one</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.k2xx_one2one" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the inverse FFT and image cropping</dt><dd><p>(which is the reverse of _xx2k() method)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.k2y">
<code class="descname">k2y</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.k2y" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: interpolation by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.k2y2k">
<code class="descname">k2y2k</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.k2y2k" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the integrated interpolation-gridding by the Sparse</dt><dd><p>Matrix-Vector Multiplication</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.plan">
<code class="descname">plan</code><span class="sig-paren">(</span><em>om</em>, <em>Nd</em>, <em>Kd</em>, <em>Jd</em>, <em>ft_axes=None</em>, <em>batch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Plan the NUFFT_cpu object with the geometry provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size = M * ndims</em>) – The M off-grid locates in the frequency domain,
which is normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the equispaced image.
Example: Nd=(256,256) for a 2D image;</p>
<blockquote>
<div><p>Nd = (128,128,128) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the oversampled frequency grid.
Example: Kd=(512,512) for 2D image;</p>
<blockquote>
<div><p>Kd = (256,256,256) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The interpolator size.
Example: Jd=(6,6) for 2D image;</p>
<blockquote>
<div><p>Jd = (6,6,6) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>ft_axes</strong> (<em>None</em><em>, or </em><em>tuple with optional integer elements.</em>) – (Optional) The axes for Fourier transform.
The default is all axes if ‘None’ is given.</p></li>
<li><p><strong>batch</strong> (<em>None</em><em>, or </em><em>integer</em>) – (Optional) Batch mode.
If the batch is provided, the last appended axis is the number
of identical NUFFT to be transformed.
The default is ‘None’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Nd</strong> – initial value: Nd</p></li>
<li><p><strong>Kd</strong> – initial value: Kd</p></li>
<li><p><a class="reference internal" href="index.html#pynufft.linalg.nufft_cpu.NUFFT_cpu.Jd" title="pynufft.linalg.nufft_cpu.NUFFT_cpu.Jd"><strong>Jd</strong></a> – initial value: Jd</p></li>
<li><p><strong>ft_axes</strong> – initial value: None</p></li>
<li><p><strong>batch</strong> – initial value: None</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.selfadjoint">
<code class="descname">selfadjoint</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.selfadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT (Toeplitz) on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>y</em>, <em>solver=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve NUFFT_cpu.
:param y: data, numpy.complex64. The shape = (M,) or (M, batch)
:param solver: ‘cg’, ‘L1TVOLS’, ‘lsmr’, ‘lsqr’, ‘dc’, ‘bicg’,</p>
<blockquote>
<div><p>‘bicgstab’, ‘cg’, ‘gmres’,’lgmres’</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array with size.
The shape = Nd (‘L1TVOLS’) or  Nd + (batch,)
(‘lsmr’, ‘lsqr’, ‘dc’,’bicg’,’bicgstab’,’cg’, ‘gmres’,’lgmres’)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.vec2k">
<code class="descname">vec2k</code><span class="sig-paren">(</span><em>k_vec</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.vec2k" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorting the vector to k-spectrum Kd array</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.vec2y">
<code class="descname">vec2y</code><span class="sig-paren">(</span><em>k_vec</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.vec2y" title="Permalink to this definition">¶</a></dt>
<dd><p>gridding:</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.x2xx">
<code class="descname">x2xx</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.x2xx" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: Scaling on CPU
Inplace multiplication of self.x_Nd by the scaling factor self.sn.</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2k">
<code class="descname">xx2k</code><span class="sig-paren">(</span><em>xx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2k" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on CPU</p>
<p>Firstly, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2k_one2one">
<code class="descname">xx2k_one2one</code><span class="sig-paren">(</span><em>xx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2k_one2one" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on CPU</p>
<p>First, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2x">
<code class="descname">xx2x</code><span class="sig-paren">(</span><em>xx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.xx2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: rescaling, which is identical to the  _x2xx() method</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.y2k">
<code class="descname">y2k</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.y2k" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: gridding by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_cpu.NUFFT_cpu.y2vec">
<code class="descname">y2vec</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_cpu.NUFFT_cpu.y2vec" title="Permalink to this definition">¶</a></dt>
<dd><p>regridding non-uniform data (unsorted vector)</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.nufft_hsa"></span><div class="section" id="nufft-hsa-classes">
<h3>NUFFT HSA classes<a class="headerlink" href="#nufft-hsa-classes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa">
<em class="property">class </em><code class="descclassname">pynufft.linalg.nufft_hsa.</code><code class="descname">NUFFT_hsa</code><span class="sig-paren">(</span><em>API=None</em>, <em>platform_number=None</em>, <em>device_number=None</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa" title="Permalink to this definition">¶</a></dt>
<dd><p>NUFFT_hsa class.
Multi-coil or single-coil memory reduced NUFFT.</p>
<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>API=None</em>, <em>platform_number=None</em>, <em>device_number=None</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>API</strong> (<em>string</em>) – The API for the heterogeneous system. API=’cuda’
or API=’ocl’</p></li>
<li><p><strong>platform_number</strong> (<em>integer</em>) – The number of the platform found by the API.</p></li>
<li><p><strong>device_number</strong> (<em>integer</em>) – The number of the device found on the platform.</p></li>
<li><p><strong>verbosity</strong> (<em>integer</em>) – Defines the verbosity level, default value is 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_hsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">(</span><span class="n">API</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">platform_number</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="go">                                 device_number=0, verbosity=0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.adjoint">
<code class="descname">adjoint</code><span class="sig-paren">(</span><em>gy</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gy</strong> – The input gpu array, with size=(M,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.forward">
<code class="descname">forward</code><span class="sig-paren">(</span><em>gx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype = numpy.complex64</em>) – The input gpu array, with size = Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gy: The output gpu array, with size = (M,)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype = numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.k2xx">
<code class="descname">k2xx</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.k2xx" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: the inverse FFT and image cropping (which is the reverse of
_xx2k() method)</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.k2y">
<code class="descname">k2y</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.k2y" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: interpolation by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.offload">
<code class="descname">offload</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.offload" title="Permalink to this definition">¶</a></dt>
<dd><p>self.offload():</p>
<p>Off-load NUFFT to the opencl or cuda device(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>API</strong> (<em>string</em>) – define the device type, which can be ‘cuda’ or ‘ocl’</p></li>
<li><p><strong>platform_number</strong> (<em>int</em>) – define which platform to be used.
The default platform_number = 0.</p></li>
<li><p><strong>device_number</strong> (<em>int</em>) – define which device to be used.
The default device_number = 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self: instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.plan">
<code class="descname">plan</code><span class="sig-paren">(</span><em>om</em>, <em>Nd</em>, <em>Kd</em>, <em>Jd</em>, <em>ft_axes=None</em>, <em>batch=None</em>, <em>radix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Design the multi-coil or single-coil memory reduced interpolator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size =</em><em> (</em><em>M</em><em>, </em><em>ndims</em><em>)</em>) – The M off-grid locations in the frequency domain.
Normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of equispaced image.
Example: Nd=(256, 256) for a 2D image;</p>
<blockquote>
<div><p>Nd = (128, 128, 128) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The matrix size of the oversampled frequency grid.
Example: Kd=(512,512) for 2D image;
Kd = (256,256,256) for a 3D image</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The interpolator size.
Example: Jd=(6,6) for 2D image;
Jd = (6,6,6) for a 3D image</p></li>
<li><p><strong>ft_axes</strong> (<em>tuple</em><em>, </em><em>selected axes to be transformed.</em>) – The dimensions to be transformed by FFT.
Example: ft_axes = (0, 1) for 2D,
ft_axes = (0, 1, 2) for 3D;
ft_axes = None for all dimensions.</p></li>
<li><p><strong>batch</strong> (<em>int</em><em> or </em><em>None</em>) – Batch NUFFT.
If provided, the shape is Nd + (batch, ).
The last axis is the number of parallel coils.
batch = None for single coil.</p></li>
<li><p><strong>radix</strong> – ????.
If provided, the shape is Nd + (batch, ).
The last axis is the number of parallel coils.
batch = None for single coil.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_hsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_hsa</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.selfadjoint">
<code class="descname">selfadjoint</code><span class="sig-paren">(</span><em>gx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.selfadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT (Toeplitz) on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype =numpy.complex64</em>) – The input gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.selfadjoint_one2many2one">
<code class="descname">selfadjoint_one2many2one</code><span class="sig-paren">(</span><em>gx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.selfadjoint_one2many2one" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint_one2many2one NUFFT (Teplitz) on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype =numpy.complex64</em>) – The input gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>gy</em>, <em>solver=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver of NUFFT_hsa</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gy</strong> (<em>reikna array</em><em>, </em><em>dtype = numpy.complex64</em>) – data, reikna array, (M,) size</p></li>
<li><p><strong>solver</strong> (<em>string</em>) – could be ‘cg’, ‘L1TVOLS’, ‘L1TVLAD’</p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reikna array with size Nd</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.xx2k">
<code class="descname">xx2k</code><span class="sig-paren">(</span><em>xx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.xx2k" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on the heterogeneous device</p>
<p>First, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="method">
<dt id="pynufft.linalg.nufft_hsa.NUFFT_hsa.y2k">
<code class="descname">y2k</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.NUFFT_hsa.y2k" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: gridding by the Sparse Matrix-Vector Multiplication
However, serial atomic add is far too slow and inaccurate.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.nufft_hsa.push_cuda_context">
<code class="descclassname">pynufft.linalg.nufft_hsa.</code><code class="descname">push_cuda_context</code><span class="sig-paren">(</span><em>hsa_method</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nufft_hsa.push_cuda_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator: Push cude context to the top of the stack for current use
Add &#64;push_cuda_context before the methods of NUFFT_hsa()</p>
</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.solve_cpu"></span><div class="section" id="cpu-solvers">
<h3>CPU solvers<a class="headerlink" href="#cpu-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pynufft.linalg.solve_cpu.L1TVOLS">
<code class="descclassname">pynufft.linalg.solve_cpu.</code><code class="descname">L1TVOLS</code><span class="sig-paren">(</span><em>nufft</em>, <em>y</em>, <em>maxiter</em>, <em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.L1TVOLS" title="Permalink to this definition">¶</a></dt>
<dd><p>L1-total variation regularized ordinary least square</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_cpu._create_kspace_sampling_density">
<code class="descclassname">pynufft.linalg.solve_cpu.</code><code class="descname">_create_kspace_sampling_density</code><span class="sig-paren">(</span><em>nufft</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu._create_kspace_sampling_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute k-space sampling density</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_cpu._pipe_density">
<code class="descclassname">pynufft.linalg.solve_cpu.</code><code class="descname">_pipe_density</code><span class="sig-paren">(</span><em>nufft</em>, <em>maxiter</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu._pipe_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the density function by iterative solution
Generate pHp matrix</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_cpu.cDiff">
<code class="descclassname">pynufft.linalg.solve_cpu.</code><code class="descname">cDiff</code><span class="sig-paren">(</span><em>x</em>, <em>d_indx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute image gradient, which needs the results of indxmap_diff(Nd)
:param x: The image array
:param d_indx: The index of the shifted image
:type x: numpy.float array, matrix size = Nd
:type d_indx: int32
:returns: x_diff: Image gradient determined by d_indx
:rtype: x_diff: numpy.complex64</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_cpu.solve">
<code class="descclassname">pynufft.linalg.solve_cpu.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>nufft</em>, <em>y</em>, <em>solver=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve NUFFT.
The current version supports solvers = ‘cg’ or ‘L1TVOLS’ or ‘L1TVLAD’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nufft</strong> – NUFFT_cpu object</p></li>
<li><p><strong>y</strong> – (M,) array, non-uniform data</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x: image</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.solve_hsa"></span><div class="section" id="hsa-solvers">
<h3>HSA solvers<a class="headerlink" href="#hsa-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pynufft.linalg.solve_hsa.L1TVLAD">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">L1TVLAD</code><span class="sig-paren">(</span><em>nufft</em>, <em>gy</em>, <em>maxiter</em>, <em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.L1TVLAD" title="Permalink to this definition">¶</a></dt>
<dd><p>(testing) L1-total variation regularized least absolute deviation</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_hsa.L1TVOLS">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">L1TVOLS</code><span class="sig-paren">(</span><em>nufft</em>, <em>gy</em>, <em>maxiter</em>, <em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.L1TVOLS" title="Permalink to this definition">¶</a></dt>
<dd><p>L1-total variation regularized ordinary least square</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_hsa._create_kspace_sampling_density">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">_create_kspace_sampling_density</code><span class="sig-paren">(</span><em>nufft</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa._create_kspace_sampling_density" title="Permalink to this definition">¶</a></dt>
<dd><p>(stable) Compute k-space sampling density from the nufft object</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_hsa._pipe_density">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">_pipe_density</code><span class="sig-paren">(</span><em>nufft</em>, <em>maxiter</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa._pipe_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: create the density function in the data space by a iterative solution
Pipe et al. 1999</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_hsa.cDiff">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">cDiff</code><span class="sig-paren">(</span><em>x</em>, <em>d_indx</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>(stable) Compute image gradient
Work with indxmap_diff(Nd).
…</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.linalg.solve_hsa.solve">
<code class="descclassname">pynufft.linalg.solve_hsa.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>nufft</em>, <em>gy</em>, <em>solver=None</em>, <em>maxiter=30</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The solve function of NUFFT_hsa.
The current version supports solvers = ‘cg’ or ‘L1TVOLS’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nufft</strong> – NUFFT_hsa object</p></li>
<li><p><strong>y</strong> (<em>numpy.complex64 reikna array</em>) – (M,) or (M, batch) array, non-uniform data. If batch is provided, ‘cg’ and ‘L1TVOLS’ returns different image shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x: Nd or Nd + (batch, ) image. L1TVOLS always returns Nd. ‘cg’ returns Nd + (batch, ) in batch mode.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>x: reikna array, complex64.</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pynufft.src._helper.helper"></span><div class="section" id="helper-functions">
<h3>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pynufft.src._helper.helper.ELL">
<em class="property">class </em><code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">ELL</code><span class="sig-paren">(</span><em>elldata</em>, <em>ellcol</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.ELL" title="Permalink to this definition">¶</a></dt>
<dd><p>ELL is slow on a single core CPU</p>
<dl class="method">
<dt id="pynufft.src._helper.helper.ELL.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>elldata</em>, <em>ellcol</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.ELL.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.src._helper.helper.ELL.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.ELL.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.OMEGA_k">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">OMEGA_k</code><span class="sig-paren">(</span><em>J</em>, <em>K</em>, <em>omd</em>, <em>Kd</em>, <em>dimid</em>, <em>dd</em>, <em>ft_flag</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.OMEGA_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the index of k-space k_indx</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.QR_process">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">QR_process</code><span class="sig-paren">(</span><em>om</em>, <em>N</em>, <em>J</em>, <em>K</em>, <em>sn</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.QR_process" title="Permalink to this definition">¶</a></dt>
<dd><p>1D QR method for generating min-max interpolator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float32</em>) – non-Cartesian coordinate. shape = (M, dims)</p></li>
<li><p><strong>N</strong> (<em>int</em>) – length</p></li>
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled grid</p></li>
<li><p><strong>sn</strong> (<em>numpy.float32 shape =</em><em> (</em><em>N</em><em>,</em><em>)</em>) – scaling factor as a length-N vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pynufft.src._helper.helper.Tensor_sn">
<em class="property">class </em><code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">Tensor_sn</code><span class="sig-paren">(</span><em>snd</em>, <em>radix</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented:</p>
<dl class="method">
<dt id="pynufft.src._helper.helper.Tensor_sn.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>snd</em>, <em>radix</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.src._helper.helper.Tensor_sn.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.block_outer_prod">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">block_outer_prod</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply x1 (J1 x M) and x2 (J2xM) and extend the dimensions to 3D (J1xJ2xM)</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.block_outer_sum">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">block_outer_sum</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the new index after adding a new axis</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.block_outer_sum0">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">block_outer_sum0</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_sum0" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply x1 (J1 x M) and x2 (J2xM) and extend the dimensions to 3D (J1xJ2xM)</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.cat_snd">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">cat_snd</code><span class="sig-paren">(</span><em>snd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.cat_snd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>snd</strong> (<em>tuple</em>) – tuple of input 1D vectors</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tensor_sn: vector of concatenated scaling factor, shape = (numpy.sum(Nd), )</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tensor_sn: numpy.float32</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.create_laplacian_kernel">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">create_laplacian_kernel</code><span class="sig-paren">(</span><em>nufft</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.create_laplacian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the multi-dimensional laplacian kernel in k-space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nufft</strong> – the NUFFT object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>uker: the multi-dimensional laplacian kernel in k-space (no fft shift used)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.create_partialELL">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">create_partialELL</code><span class="sig-paren">(</span><em>ud</em>, <em>kd</em>, <em>Jd</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.create_partialELL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ud</strong> (<em>tuple of numpy.complex64 arrays</em>) – tuple of all 1D interpolators</p></li>
<li><p><strong>kd</strong> (<em>tuple of numpy.int32 arrays</em>) – tuple of all 1D indices</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int32</em>) – tuple of interpolation sizes</p></li>
<li><p><strong>M</strong> (<em>int</em>) – number of samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>partialELL:</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>partialELL: pELL instance</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.crop_slice_ind">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">crop_slice_ind</code><span class="sig-paren">(</span><em>Nd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.crop_slice_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated in v.0.3.4)
Return the “slice” of Nd size to index multi-dimensional array.  “Slice” functions as the index of the array.
This function is superseded by preindex_copy(), which avoid run-time indexing.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.device_list">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">device_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.device_list" title="Permalink to this definition">¶</a></dt>
<dd><p>device_list() returns available devices for acceleration as a tuple.
If no device is available, it returns an empty tuple.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.diagnose">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">diagnose</code><span class="sig-paren">(</span><em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.diagnose" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagnosis function
Find available devices when NUFFT.offload() fails.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.get_sn">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">get_sn</code><span class="sig-paren">(</span><em>J</em>, <em>K</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.get_sn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 1D scaling factor for the given J, K, N</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled grid</p></li>
<li><p><strong>N</strong> (<em>int</em>) – length</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sn:  scaling factor as a length-N vector</p>
</dd>
<dt class="field-odd">Rtype sn</dt>
<dd class="field-odd"><p>numpy.float32 shape = (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.indxmap_diff">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">indxmap_diff</code><span class="sig-paren">(</span><em>Nd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.indxmap_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Preindixing for rapid image gradient.
Diff(x) = x.flat[d_indx[0]] - x.flat
Diff_t(x) =  x.flat[dt_indx[0]] - x.flat</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Nd</strong> (<em>tuple with integers</em>) – the dimension of the image</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>d_indx: image gradient</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dt_indx:  the transpose of the image gradient</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>d_indx: lists with numpy ndarray</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dt_indx: lists with numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.kaiser_bessel_ft">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">kaiser_bessel_ft</code><span class="sig-paren">(</span><em>u</em>, <em>J</em>, <em>alpha</em>, <em>kb_m</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.kaiser_bessel_ft" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolation weight for given J/alpha/kb-m</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.kronecker_scale">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">kronecker_scale</code><span class="sig-paren">(</span><em>snd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.kronecker_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kronecker product of the scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snd</strong> (<em>tuple of 1D numpy.array</em>) – Tuple of 1D scaling factors</p></li>
<li><p><strong>dd</strong> – Number of dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sn: The multi-dimensional Kronecker of the scaling factors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nd array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.nufft_T">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">nufft_T</code><span class="sig-paren">(</span><em>N</em>, <em>J</em>, <em>K</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_T" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation (29) and (26) in Fessler and Sutton 2003.
Create the overlapping matrix CSSC (diagonal dominant matrix)
of J points, then find the pseudo-inverse of CSSC</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.nufft_alpha_kb_fit">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">nufft_alpha_kb_fit</code><span class="sig-paren">(</span><em>N</em>, <em>J</em>, <em>K</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_alpha_kb_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find parameters alpha and beta for scaling factor st[‘sn’]
The alpha is hardwired as [1,0,0…] when J = 1 (uniform scaling factor)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – size of image</p></li>
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled k-space</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>alphas:</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>beta:</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>alphas: list of float</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>beta:</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.nufft_offset">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">nufft_offset</code><span class="sig-paren">(</span><em>om</em>, <em>J</em>, <em>K</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For every om point (outside regular grids), find the nearest
central grid (from Kd dimension)</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.nufft_r">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">nufft_r</code><span class="sig-paren">(</span><em>om</em>, <em>N</em>, <em>J</em>, <em>K</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation (30) of Fessler &amp; Sutton’s paper</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.nufft_scale1">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">nufft_scale1</code><span class="sig-paren">(</span><em>N</em>, <em>K</em>, <em>alpha</em>, <em>beta</em>, <em>Nmid</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_scale1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate image space scaling factor</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.outer_sum">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">outer_sum</code><span class="sig-paren">(</span><em>xx</em>, <em>yy</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.outer_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Superseded by numpy.add.outer() function</p>
</dd></dl>

<dl class="class">
<dt id="pynufft.src._helper.helper.pELL">
<em class="property">class </em><code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">pELL</code><span class="sig-paren">(</span><em>M</em>, <em>Jd</em>, <em>curr_sumJd</em>, <em>meshindex</em>, <em>kindx</em>, <em>udata</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.pELL" title="Permalink to this definition">¶</a></dt>
<dd><p>class pELL: partial ELL format</p>
<dl class="method">
<dt id="pynufft.src._helper.helper.pELL.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>M</em>, <em>Jd</em>, <em>curr_sumJd</em>, <em>meshindex</em>, <em>kindx</em>, <em>udata</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.pELL.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>int</em>) – Number of samples</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – Interpolator size</p></li>
<li><p><strong>curr_sumJd</strong> (<em>tuple of int</em>) – Summation of Jd[0:d-1], for fast shift computing</p></li>
<li><p><strong>meshindex</strong> (<em>numpy.uint32</em><em>, </em><em>shape =</em><em>  (</em><em>numpy.prod</em><em>(</em><em>Jd</em><em>)</em><em>,  </em><em>dd</em><em>)</em>) – The tensor indices to all interpolation points</p></li>
<li><p><strong>kindx</strong> (<em>numpy.uint32</em><em>, </em><em>shape =</em><em> (</em><em>M</em><em>, </em><em>numpy.sum</em><em>(</em><em>Jd</em><em>)</em><em>)</em>) – Premixed k-indices to be combined</p></li>
<li><p><strong>udata</strong> (<em>numpy.complex64</em><em>, </em><em>shape =</em><em> (</em><em>M</em><em>, </em><em>numpy.sum</em><em>(</em><em>Jd</em><em>)</em><em>)</em>) – Premixed interpolation data values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pELL: partial ELLpack class with the given values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pELL: partial ELLpack class</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pynufft.src._helper.helper.pELL.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.pELL.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.plan">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">plan</code><span class="sig-paren">(</span><em>om</em>, <em>Nd</em>, <em>Kd</em>, <em>Jd</em>, <em>ft_axes=None</em>, <em>format='CSR'</em>, <em>radix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Plan for the NUFFT object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float</em>) – Coordinate</p></li>
<li><p><strong>Nd</strong> (<em>tuple of int</em>) – Image shape</p></li>
<li><p><strong>Kd</strong> (<em>tuple of int</em>) – Oversampled grid shape</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – Interpolator size</p></li>
<li><p><strong>ft_axes</strong> (<em>tuple of int</em>) – Axes where FFT takes place</p></li>
<li><p><strong>format</strong> (<em>string</em><em>, </em><em>'CSR'</em><em> or </em><em>'pELL'</em>) – Output format of the interpolator.
‘CSR’: the precomputed Compressed Sparse Row (CSR) matrix.
‘pELL’: partial ELLPACK which precomputes the concatenated 1D interpolators.</p></li>
</ul>
</dd>
<dt class="field-even">Return st</dt>
<dd class="field-even"><p>dictionary for NUFFT</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.plan1">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">plan1</code><span class="sig-paren">(</span><em>om</em>, <em>Nd</em>, <em>Kd</em>, <em>Jd</em>, <em>ft_axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.plan1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the coil sensitivity aware interpolator</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.preindex_copy">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">preindex_copy</code><span class="sig-paren">(</span><em>Nd</em>, <em>Kd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.preindex_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Building the array index for copying two arrays of sizes Nd and Kd.
Only the front parts of the input/output arrays are copied.
The oversize  parts of the input array are truncated (if Nd &gt; Kd), 
and the smaller size are zero-padded (if Nd &lt; Kd)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Nd</strong> (<em>tuple with integer elements</em>) – tuple, the dimensions of array1</p></li>
<li><p><strong>Kd</strong> (<em>tuple with integer elements</em>) – tuple, the dimensions of array2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inlist: the index of the input array</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>outlist: the index of the output array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nelem: the length of the inlist and outlist (equal length)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>inlist: list with integer elements</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>outlist: list with integer elements</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nelem: int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.rdx_kron">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">rdx_kron</code><span class="sig-paren">(</span><em>ud</em>, <em>kd</em>, <em>Jd</em>, <em>radix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.rdx_kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Radix-n Kronecker product of multi-dimensional array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ud</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.complex64 arrays</em>) – 1D interpolators</p></li>
<li><p><strong>kd</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.uint arrays</em>) – 1D indices to interpolators</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – 1D interpolator sizes</p></li>
<li><p><strong>radix</strong> (<em>int</em>) – radix of Kronecker product</p></li>
<li><p><strong>kk</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.uint arrays</em>) – 1D indices to interpolators</p></li>
<li><p><strong>JJ</strong> (<em>tuple of int</em>) – 1D interpolator sizes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>uu: 1D interpolators</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pynufft.src._helper.helper.strides_divide_itemsize">
<code class="descclassname">pynufft.src._helper.helper.</code><code class="descname">strides_divide_itemsize</code><span class="sig-paren">(</span><em>Nd</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.strides_divide_itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>strides_divide_itemsize function computes the step_size (strides/itemsize) along different axes, and its inverse as float32.
For fast GPU computing, preindexing allows for fast Hadamard product and copy.
However preindexing costs some memory.
strides_divide_itemsize aims to replace preindexing by run-time calculation of the index, given the invNd_elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Nd</strong> (<em>tuple of int</em>) – Input shape</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Nd_elements: strides/itemsize of the Nd.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>invNd_elements: (float32)(1/Nd_elements). Division on GPU is slow but multiply is fast. Thus we can precompute the inverse and then multiply the inverse on GPU.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Nd_elements: tuple of int</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>invNd_elements: tuple of float32</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pynufft.NUFFT_hsa</span></code></p>
</div>
</dd></dl>

</div>
<span class="target" id="module-pynufft.src.re_subroutine"></span><div class="section" id="metaprogramming-subroutines-using-reikna-pyopencl-pycuda">
<h3>Metaprogramming subroutines (using reikna, pyopencl, pycuda)<a class="headerlink" href="#metaprogramming-subroutines-using-reikna-pyopencl-pycuda" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pynufft.src.re_subroutine.atomic_add">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">atomic_add</code><span class="sig-paren">(</span><em>API</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.atomic_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic_add for the given API. 
Overcome the missing atomic_add_float for OpenCL-1.2. 
Note: will be checked if OpenCL 2.0 provided by all GPU vendors.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cAddScalar">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cAddScalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAddScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cAddScalar.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cAddVec">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cAddVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAddVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cAddVec.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cAnisoShrink">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cAnisoShrink</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAnisoShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cAnisoShrink</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cCopy">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cCopy</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cDiff">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cDiff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cDiff.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cHadamard">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cHadamard</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cHadamard" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hadamard operations related kernel sources.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cHypot">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cHypot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cHypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel code for hypot, which computes the sqrt(x*x + y*y) without intermediate overflow.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyConjVec">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyConjVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyConjVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyConjVec.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyConjVecInplace">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyConjVecInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyConjVecInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyConjVecInplace</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyRealInplace">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyRealInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyRealInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyRealInplace.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyScalar">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyScalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cMultiplyScalar.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyVec">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyVec</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cMultiplyVecInplace">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cMultiplyVecInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyVecInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyVecInplace.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cSelect">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cSelect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cSelect.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cSpmv">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cSpmv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSpmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel sources for cSpmv related operations,
providing cCSR_spmv_vector and cpELL_spmv_mCoil.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cSpmvh">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cSpmvh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSpmvh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cSpmvh related kernel source. 
Only pELL_spmvh_mCoil is provided for Spmvh.
NUFFT_hsa_legacy reuses the cCSR_spmv() function, which doubles the storage.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cSqrt">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cSqrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cSqrt.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cTensorCopy">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cTensorCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cTensorCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cTensorCopy.</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.cTensorMultiply">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">cTensorMultiply</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cTensorMultiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cTensorMultiply</p>
</dd></dl>

<dl class="function">
<dt id="pynufft.src.re_subroutine.create_kernel_sets">
<code class="descclassname">pynufft.src.re_subroutine.</code><code class="descname">create_kernel_sets</code><span class="sig-paren">(</span><em>API</em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.create_kernel_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the kernel from the kernel sets.
Note that in some tests (Benoit’s and my tests) CUDA shows some degraded accuracy. 
This loss of accuracy was due to undefined shared memory behavior, which I don’t fully understand.
This has been fixed in 2019.2.0 as the operations are moved to global memory.</p>
</dd></dl>

</div>
</div>
<span id="document-installation/init"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="system-requirements">
<h3>System requirements<a class="headerlink" href="#system-requirements" title="Permalink to this headline">¶</a></h3>
<p><strong>CPU</strong></p>
<p>Each PyNUFFT instance is designed to be executed on a single node.
PyNUFFT is not designed for distributed computing on multiple nodes,
but the user may install PyNUFFT on multiple nodes and control them through the network.</p>
<p>Multple NUFFT_cpu instances on a single node provided that the total memory is sufficient to keep all instances.</p>
<p>We recommend one or more modern x86_64 processors on a single node. Successful stories include Intel® Core™ i7-6700HQ Processor,
Intel® Xeon® W-2125, Intel® Core™ i9-7900X.</p>
<p><strong>Memory</strong></p>
<p>A general instruction is that the memory should be sufficient for computing a single NUFFT object, which is dependent on the type of problem.</p>
<p>A single 2D problem of 256 × 256 matrix can be computed on a system with 8GB memory.</p>
<p>For 3D NUFFT, it is not uncommon for a single NUFFT_cpu object to consume more than 200GB memory.</p>
<p><strong>GPU</strong></p>
<p>Each PyNUFFT instance is initiated on a single GPU. An instance cannot be distributed across multiple GPUs.
(PyNUFFT does not use cuFFT.)</p>
<p>However, multiple NUFFT_hsa instances may be initiated both on a single GPU and on multiple GPUs,
but the performance may be impacted (limited by the memory, PCI-E bus or GPU cores).</p>
<p>To use GPU, a recent NVIDIA’s GPU (after Maxwell, Pascal) with the recent drivers should be working properly.</p>
<p>The newest nvidia-driver versions of 415.18 or later is recommended.
Earlier versions may work but please be informed that Nvidia may discontinue support for outdated drivers.</p>
<p>A general rule is that the memory on the GPU has to be sufficient for computing the NUFFT problem.
Successful stories include NVIDIA Geforce GTX 965m/GTX 1070 maxQ/1060 6GB,
NVIDIA Titan V100 (Amazon Web Services),
NVIDIA Titan X Pascal,
and NVIDIA Quadro P6000.</p>
<p><strong>Operating System</strong></p>
<p>Ubunut 16.04 - 18.04 are recommended.</p>
<p>Windows 10 has been tested but it requires Microsoft Studio 2015 community. Please refer to the following special topic about the installation under Windows 10.</p>
</div>
<div class="section" id="software">
<h3>Software<a class="headerlink" href="#software" title="Permalink to this headline">¶</a></h3>
<p><strong>Python</strong></p>
<p>Users must be familiar with Python and its pip packaging system.
Python 2.7 and Python 3.6-3.7 are currently supported.</p>
<p>To run the NUFFT_cpu, the basic CPython, Numpy and Scipy packages must be available on the system.
IronPython is compatible with CPython so ipython might be useful.</p>
<p>PyNUFFT can be installed through the pip command.
Optionally, users can clone the github repository and build the package from the local folder.</p>
<p><strong>Compiler</strong></p>
<p>NUFFT_cpu class does not require a compiler.</p>
<p>However, NUFFT_hsa relies on the JIT (just-in-time) compilation mechanism of Reikna/PyCUDA/PyOpenCL.
The supporting compiler may be:</p>
<ul class="simple">
<li><p>gcc-7.3.0</p></li>
<li><p>Microsoft (R) Visual Studio 2015 community edition.</p></li>
</ul>
<p>(Please refer to the following section: special topic: Installation under Windows 10).</p>
<p>To accelerate the code on the graphic processing unit (GPU),
Reikna, PyCUDA, PyOpencl must be available. Please refer the following special topic: Installation of OpenCL.</p>
<p>CUDA programming skills are not strictly needed.
However, it may be helpful if users understand GPU programming.</p>
</div>
<div class="section" id="general-installation">
<h3>General Installation<a class="headerlink" href="#general-installation" title="Permalink to this headline">¶</a></h3>
<p>Continuum’s <a class="reference external" href="https://www.continuum.io/downloads">Anaconda</a> environment should provide all the above packages.</p>
<p><strong>Installation using pip</strong></p>
<p>Install pynufft by using the <a class="reference external" href="https://en.wikipedia.org/wiki/Pip_(package_manager)">pip</a> command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pip install pynufft
</pre></div>
</div>
<p><strong>Installation from Git Repository</strong></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Git">git</a> is a version control program, which allows you to clone the latest code base from the <a class="reference external" href="https://github.com/jyhmiinlin/pynufft">pynufft</a> repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/jyhmiinlin/pynufft
$ cd pynufft
$ python setup.py install --user
</pre></div>
</div>
<p><strong>Test whether the installation is successful</strong></p>
<p>In Python environment, import pynufft:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pynufft.tests</span> <span class="k">as</span> <span class="nn">tests</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tests</span><span class="o">.</span><span class="n">test_installation</span><span class="p">()</span>
</pre></div>
</div>
<p>If the required data and functions are available, you will see that all the required files exist:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">om1D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">om2D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">om3D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">phantom_3D_128_128_128</span><span class="o">.</span><span class="n">npz</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">phantom_256_256</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">example_1D</span><span class="o">.</span><span class="n">py</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">example_2D</span><span class="o">.</span><span class="n">py</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">reikna</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
<span class="n">pyopencl</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
<span class="n">pycuda</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Uninstall pynufft</strong></p>
<p>Simply use “pip uninstall” to remove pynufft:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pip uninstall pynufft
</pre></div>
</div>
</div>
<div class="section" id="special-topics">
<h3>Special topics<a class="headerlink" href="#special-topics" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-installation/Linux"></span><div class="section" id="installation-under-linux">
<h4>Installation under Linux<a class="headerlink" href="#installation-under-linux" title="Permalink to this headline">¶</a></h4>
<p><strong>Ubuntu 18.04</strong></p>
<p>A successful example is Ubuntu.</p>
<p>The working kernel shown in <cite>uname -a</cite> is 4.15.0-42-generic #45-Ubuntu.</p>
<p>The Nvidia related packages are: Nvidia-driver Version: 410.78       CUDA Version: 10.0</p>
<p><strong>Gentoo</strong></p>
<p>PyNUFF works with the package in Gentoo system:
dev-util/nvidia-cuda-sdk-9.2.88, dev-util/nvidia-cuda-toolkit-9.2.88,
dev-util/intel-ocl-sdk-4.4.0.117-r1, and x11-drivers/nvidia-drivers-430.40.</p>
</div>
<span id="document-installation/Windows"></span><div class="section" id="installation-under-windows-10">
<h4>Installation under Windows 10<a class="headerlink" href="#installation-under-windows-10" title="Permalink to this headline">¶</a></h4>
<p>PyNUFFT has been tested under the Windows 10 home edition.</p>
<p>The successful installation experience may be useful, but the actual process can be different due to the variety of software and hardware environments.</p>
<p>I used Nvidia-driver 417.35-notebook-win10-64bit-international-whql-rp, Anaconda3-2018.12-Windows-x86_64, PyCUDA 2018.1.1 from official pip, Microsoft Visual Studio 2015 Community, CUDA 9.2.148_win10 and cuda_9.2.148.1_windows (patch).</p>
<p>The following general guidance may work in your case but cannot be guaranteed.</p>
<p><strong>Pre-requisites</strong></p>
<ul class="simple">
<li><p>GPU, a clean Windows 10, Windows Visual Studio 2015 Community Version and CUDA 9.2.148</p></li>
</ul>
<p>This is the most complex step. Please refer to the official documentation of Nvidia:</p>
<p><cite>https://docs.nvidia.com/cuda/archive/9.2/cuda-installation-guide-microsoft-windows/index.html</cite></p>
<ul class="simple">
<li><p>First, install the Nvidia-driver 417.35-notebook-win10-64bit-international-whql-rp.</p></li>
<li><p>Second, install the Microsoft Visual Studio 2015 Community.</p></li>
<li><p>Third, install CUDA-9.2. Do not install an older driver.</p></li>
</ul>
<p>Now open command prompt <cite>cmd</cite>, type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nvcc</span> <span class="o">-</span><span class="n">V</span>
</pre></div>
</div>
<p>You may see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nvcc</span><span class="p">:</span> <span class="n">NVIDIA</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Cuda</span> <span class="n">compiler</span> <span class="n">driver</span>
<span class="n">Copyright</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="mi">2005</span><span class="o">-</span><span class="mi">2018</span> <span class="n">NVIDIA</span> <span class="n">Corporation</span>
<span class="n">Built</span> <span class="n">on</span> <span class="n">Tue_Jun_12_23</span><span class="p">:</span><span class="mi">09_12</span><span class="n">_Central_Daylight_time_2018</span>
<span class="n">Cuda</span> <span class="n">compilation</span> <span class="n">tool</span><span class="p">,</span> <span class="n">release</span> <span class="mf">9.2</span><span class="p">,</span> <span class="n">V9</span><span class="o">.</span><span class="mf">2.148</span>
</pre></div>
</div>
<p>which indicates that nvcc can be found in the system.</p>
<ul class="simple">
<li><p>Add the environmental variable path.</p></li>
</ul>
<p>If the system cannot find <cite>cl.exe</cite> when you type <cite>cl</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>C:\Users\User&gt;cl
`cl` is not recognized as an internal or external command,
operable program or batch file.
</pre></div>
</div>
<p>this error is due to the fact that Visual Studio has not been added to the system path, so the system cannot find cl.</p>
<p>Try to follow the webpage instruction at <cite>https://docs.microsoft.com/en-us/previous-versions/office/developer/sharepoint-2010/ee537574(v%3Doffice.14)</cite>.
Add “C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin” and “C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE”.</p>
<p>Once Visual Studio has been added to the system, open Windows cmd and it should find cl.exe</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\<span class="n">Users</span>\<span class="n">User</span><span class="o">&gt;</span><span class="n">cl</span>
<span class="n">Microsoft</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">C</span><span class="o">/</span><span class="n">C</span><span class="o">++</span> <span class="n">Optimizing</span> <span class="n">Compiler</span> <span class="n">Version</span> <span class="mf">19.0024215</span><span class="o">.</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x86</span>
<span class="n">Copyright</span> <span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">Microsoft</span> <span class="n">Corpooration</span><span class="o">.</span> <span class="n">All</span> <span class="n">rights</span> <span class="n">reserved</span><span class="o">.</span>

<span class="n">usage</span><span class="p">:</span> <span class="n">cl</span> <span class="p">[</span> <span class="n">option</span><span class="o">...</span> <span class="p">]</span> <span class="n">filename</span><span class="o">...</span> <span class="p">[</span> <span class="o">/</span><span class="n">link</span> <span class="n">linkoption</span><span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<p>without the earlier error message. If the error persists, the path must be modified again.</p>
<p><strong>Installation of Anaconda3</strong></p>
<ul class="simple">
<li><p>Now install Anaconda3. I downloaded Anaconda3-2018.12-Windows-x86_64. Once this is done you can follow the general installation procedure as described above.</p></li>
</ul>
<p><strong>Installation of Pytools, PyCUDA, and PyNUFFT</strong></p>
<ul>
<li><p>Open Anaconda3 command prompt, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pytools</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pycuda</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">reikna</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pynufft</span>
</pre></div>
</div>
</li>
<li><p>Test PyNUFFT:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span>
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">tests</span>
<span class="n">tests</span><span class="o">.</span><span class="n">test_init</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</div>
<span id="document-installation/OpenCL"></span><div class="section" id="installation-of-opencl">
<h4>Installation of OpenCL<a class="headerlink" href="#installation-of-opencl" title="Permalink to this headline">¶</a></h4>
<p>OpenCL is one of the backends that PyNUFFT supports. Up to the present, PyNUFFT has used OpenCL-1.2. One missing feature of OpenCL-1.2 is <cite>atomicAdd</cite> for the array with floating point numbers.   PyNUFFT makes use of <cite>atomic_cmpxchg</cite> (compare and exchange) to implement the atomic_add_float subroutine, which can be seen in the <cite>pynufft.src.re_subroutine.atomic_add</cite>. This code has appeared in many resources, e.g. <cite>http://simpleopencl.blogspot.com/2013/05/atomic-operations-and-floats-in-opencl.html</cite> and <cite>https://github.com/clMathLibraries/clSPARSE/blob/master/src/library/kernels/csrmv_adaptive.cl</cite>.</p>
<p>Note that the OpenCL standard is still evolving and all of the OpenCL supports may change quickly. Old sdk may not work with the newest Intel chipsets. Please try different versions of the hardware and software.</p>
<p>The current compiler version is gcc version 7.3.0. Other compilers may be used on the target system but I haven’t tested any of them.</p>
<p><strong>Intel OpenCL</strong></p>
<p>Intel HD graphics after the Skylake generation usually support OpenCL as long as the suitable intel-sdk is installed.</p>
<p>One OpenCL example is a Gigabyte aero 14 Gentoo Linux on a machine with Intel Corporation HD Graphics 530 (rev 06). The dev-util/intel-ocl-sdk-4.4.0.117-r1 installed the <cite>intel_sdk_for_ocl_applications_2014_ubuntu_4.4.0.117_x64.tgz</cite> opencl package. The <cite>clinfo</cite> command shows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Platform</span> <span class="n">Name</span>                                   <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">OpenCL</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">devices</span>                                 <span class="mi">1</span>
<span class="n">Device</span> <span class="n">Name</span>                                     <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Core</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="n">i7</span><span class="o">-</span><span class="mi">6700</span><span class="n">HQ</span> <span class="n">CPU</span> <span class="o">@</span> <span class="mf">2.60</span><span class="n">GHz</span>
<span class="n">Device</span> <span class="n">Vendor</span>                                   <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Corporation</span>
<span class="n">Device</span> <span class="n">Vendor</span> <span class="n">ID</span>                                <span class="mh">0x8086</span>
<span class="n">Device</span> <span class="n">Version</span>                                  <span class="n">OpenCL</span> <span class="mf">1.2</span> <span class="p">(</span><span class="n">Build</span> <span class="mi">117</span><span class="p">)</span>
<span class="n">Driver</span> <span class="n">Version</span>                                  <span class="mf">1.2</span><span class="o">.</span><span class="mf">0.117</span>
<span class="n">Device</span> <span class="n">OpenCL</span> <span class="n">C</span> <span class="n">Version</span>                         <span class="n">OpenCL</span> <span class="n">C</span> <span class="mf">1.2</span>
<span class="n">Device</span> <span class="n">Type</span>                                     <span class="n">CPU</span>
<span class="n">Device</span> <span class="n">Profile</span>                                  <span class="n">FULL_PROFILE</span>
<span class="n">Device</span> <span class="n">Available</span>                                <span class="n">Yes</span>
<span class="n">Compiler</span> <span class="n">Available</span>                              <span class="n">Yes</span>
<span class="n">Linker</span> <span class="n">Available</span>                                <span class="n">Yes</span>
<span class="n">Max</span> <span class="n">compute</span> <span class="n">units</span>                               <span class="mi">8</span>
<span class="n">Max</span> <span class="n">clock</span> <span class="n">frequency</span>                             <span class="mi">2600</span><span class="n">MHz</span>
<span class="n">Device</span> <span class="n">Partition</span>                                <span class="p">(</span><span class="n">core</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">sub</span><span class="o">-</span><span class="n">devices</span>                     <span class="mi">8</span>
  <span class="n">Supported</span> <span class="n">partition</span> <span class="n">types</span>                     <span class="n">by</span> <span class="n">counts</span><span class="p">,</span> <span class="n">equally</span><span class="p">,</span> <span class="n">by</span> <span class="n">names</span> <span class="p">(</span><span class="n">Intel</span><span class="p">)</span>
  <span class="n">Supported</span> <span class="n">affinity</span> <span class="n">domains</span>                    <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">dimensions</span>                        <span class="mi">3</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">sizes</span>                             <span class="mi">8192</span><span class="n">x8192x8192</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span>                             <span class="mi">8192</span>
<span class="n">Preferred</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span> <span class="n">multiple</span>              <span class="mi">128</span>
<span class="n">Preferred</span> <span class="o">/</span> <span class="n">native</span> <span class="n">vector</span> <span class="n">sizes</span>
  <span class="n">char</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">32</span>
  <span class="n">short</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">16</span>
  <span class="nb">int</span>                                                  <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
  <span class="n">long</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>
  <span class="n">half</span>                                                 <span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span>        <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="nb">float</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
  <span class="n">double</span>                                               <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>        <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
<span class="n">Half</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>           <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Single</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">core</span><span class="p">)</span>
  <span class="n">Denormals</span>                                     <span class="n">Yes</span>
  <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">No</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">No</span>
  <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">No</span>
  <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
  <span class="n">Correctly</span><span class="o">-</span><span class="n">rounded</span> <span class="n">divide</span> <span class="ow">and</span> <span class="n">sqrt</span> <span class="n">operations</span>  <span class="n">No</span>
<span class="n">Double</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
  <span class="n">Denormals</span>                                     <span class="n">Yes</span>
  <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
  <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
  <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
<span class="n">Address</span> <span class="n">bits</span>                                    <span class="mi">64</span><span class="p">,</span> <span class="n">Little</span><span class="o">-</span><span class="n">Endian</span>
<span class="n">Global</span> <span class="n">memory</span> <span class="n">size</span>                              <span class="mi">33613447168</span> <span class="p">(</span><span class="mf">31.3</span><span class="n">GiB</span><span class="p">)</span>
<span class="n">Error</span> <span class="n">Correction</span> <span class="n">support</span>                        <span class="n">No</span>
<span class="n">Max</span> <span class="n">memory</span> <span class="n">allocation</span>                           <span class="mi">8403361792</span> <span class="p">(</span><span class="mf">7.826</span><span class="n">GiB</span><span class="p">)</span>
<span class="n">Unified</span> <span class="n">memory</span> <span class="k">for</span> <span class="n">Host</span> <span class="ow">and</span> <span class="n">Device</span>              <span class="n">Yes</span>
<span class="n">Minimum</span> <span class="n">alignment</span> <span class="k">for</span> <span class="nb">any</span> <span class="n">data</span> <span class="nb">type</span>             <span class="mi">128</span> <span class="nb">bytes</span>
<span class="n">Alignment</span> <span class="n">of</span> <span class="n">base</span> <span class="n">address</span>                       <span class="mi">1024</span> <span class="n">bits</span> <span class="p">(</span><span class="mi">128</span> <span class="nb">bytes</span><span class="p">)</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="nb">type</span>                        <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">size</span>                        <span class="mi">262144</span> <span class="p">(</span><span class="mi">256</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">line</span> <span class="n">size</span>                   <span class="mi">64</span> <span class="nb">bytes</span>
<span class="n">Image</span> <span class="n">support</span>                                   <span class="n">Yes</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">samplers</span> <span class="n">per</span> <span class="n">kernel</span>             <span class="mi">480</span>
  <span class="n">Max</span> <span class="n">size</span> <span class="k">for</span> <span class="mi">1</span><span class="n">D</span> <span class="n">images</span> <span class="kn">from</span> <span class="nn">buffer</span>            <span class="mi">525210112</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="mi">1</span><span class="n">D</span> <span class="ow">or</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">array</span> <span class="n">size</span>                 <span class="mi">2048</span> <span class="n">images</span>
  <span class="n">Max</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x16384</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="mi">3</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">2048</span><span class="n">x2048x2048</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">read</span> <span class="n">image</span> <span class="n">args</span>                 <span class="mi">480</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">write</span> <span class="n">image</span> <span class="n">args</span>                <span class="mi">480</span>
<span class="n">Local</span> <span class="n">memory</span> <span class="nb">type</span>                               <span class="n">Global</span>
<span class="n">Local</span> <span class="n">memory</span> <span class="n">size</span>                               <span class="mi">32768</span> <span class="p">(</span><span class="mi">32</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">args</span>                     <span class="mi">480</span>
<span class="n">Max</span> <span class="n">constant</span> <span class="n">buffer</span> <span class="n">size</span>                        <span class="mi">131072</span> <span class="p">(</span><span class="mi">128</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">size</span> <span class="n">of</span> <span class="n">kernel</span> <span class="n">argument</span>                     <span class="mi">3840</span> <span class="p">(</span><span class="mf">3.75</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Queue</span> <span class="n">properties</span>
  <span class="n">Out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">order</span> <span class="n">execution</span>                        <span class="n">Yes</span>
  <span class="n">Profiling</span>                                     <span class="n">Yes</span>
  <span class="n">Local</span> <span class="n">thread</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Intel</span><span class="p">)</span>                <span class="n">Yes</span>
<span class="n">Prefer</span> <span class="n">user</span> <span class="n">sync</span> <span class="k">for</span> <span class="n">interop</span>                    <span class="n">No</span>
<span class="n">Profiling</span> <span class="n">timer</span> <span class="n">resolution</span>                      <span class="mi">1</span><span class="n">ns</span>
<span class="n">Execution</span> <span class="n">capabilities</span>
  <span class="n">Run</span> <span class="n">OpenCL</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
  <span class="n">Run</span> <span class="n">native</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
  <span class="n">SPIR</span> <span class="n">versions</span>                                 <span class="mf">1.2</span>
<span class="n">printf</span><span class="p">()</span> <span class="n">buffer</span> <span class="n">size</span>                            <span class="mi">1048576</span> <span class="p">(</span><span class="mi">1024</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Built</span><span class="o">-</span><span class="ow">in</span> <span class="n">kernels</span>                                <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Device</span> <span class="n">Extensions</span>                               <span class="n">cl_khr_icd</span> <span class="n">cl_khr_global_int32_base_atomics</span> <span class="n">cl_khr_global_int32_extended_atomics</span> <span class="n">cl_khr_local_int32_base_atomics</span> <span class="n">cl_khr_local_int32_extended_atomics</span> <span class="n">cl_khr_byte_addressable_store</span> <span class="n">cl_khr_spir</span> <span class="n">cl_intel_exec_by_local_thread</span> <span class="n">cl_khr_depth_images</span> <span class="n">cl_khr_3d_image_writes</span> <span class="n">cl_khr_fp64</span>
</pre></div>
</div>
<p>Pure CPU system without Intel HD graphics may require the newest Intel SDK for OpenCL <cite>https://software.intel.com/en-us/intel-opencl</cite> and <cite>https://software.intel.com/en-us/articles/opencl-drivers</cite>. One pure CPU system with Intel i7 7900X can make use of Intel Studio 2019.</p>
<p><strong>Nvidia OpenCL</strong></p>
<p>NVIDIA also supports OpenCL 1.2. A successful installation made use of nvidia-driver 417.18 and CUDA-SDK-9.2.88 and gcc 7.3.0. clinfo shows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Platform</span> <span class="n">Name</span>                                   <span class="n">NVIDIA</span> <span class="n">CUDA</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">devices</span>                                 <span class="mi">1</span>
  <span class="n">Device</span> <span class="n">Name</span>                                     <span class="n">GeForce</span> <span class="n">GTX</span> <span class="mi">1060</span>
  <span class="n">Device</span> <span class="n">Vendor</span>                                   <span class="n">NVIDIA</span> <span class="n">Corporation</span>
  <span class="n">Device</span> <span class="n">Vendor</span> <span class="n">ID</span>                                <span class="mh">0x10de</span>
  <span class="n">Device</span> <span class="n">Version</span>                                  <span class="n">OpenCL</span> <span class="mf">1.2</span> <span class="n">CUDA</span>
  <span class="n">Driver</span> <span class="n">Version</span>                                  <span class="mf">415.18</span>
  <span class="n">Device</span> <span class="n">OpenCL</span> <span class="n">C</span> <span class="n">Version</span>                         <span class="n">OpenCL</span> <span class="n">C</span> <span class="mf">1.2</span>
  <span class="n">Device</span> <span class="n">Type</span>                                     <span class="n">GPU</span>
  <span class="n">Device</span> <span class="n">Topology</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                            <span class="n">PCI</span><span class="o">-</span><span class="n">E</span><span class="p">,</span> <span class="mi">01</span><span class="p">:</span><span class="mf">00.0</span>
  <span class="n">Device</span> <span class="n">Profile</span>                                  <span class="n">FULL_PROFILE</span>
  <span class="n">Device</span> <span class="n">Available</span>                                <span class="n">Yes</span>
  <span class="n">Compiler</span> <span class="n">Available</span>                              <span class="n">Yes</span>
  <span class="n">Linker</span> <span class="n">Available</span>                                <span class="n">Yes</span>
  <span class="n">Max</span> <span class="n">compute</span> <span class="n">units</span>                               <span class="mi">10</span>
  <span class="n">Max</span> <span class="n">clock</span> <span class="n">frequency</span>                             <span class="mi">1670</span><span class="n">MHz</span>
  <span class="n">Compute</span> <span class="n">Capability</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                         <span class="mf">6.1</span>
  <span class="n">Device</span> <span class="n">Partition</span>                                <span class="p">(</span><span class="n">core</span><span class="p">)</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">sub</span><span class="o">-</span><span class="n">devices</span>                     <span class="mi">1</span>
    <span class="n">Supported</span> <span class="n">partition</span> <span class="n">types</span>                     <span class="kc">None</span>
    <span class="n">Supported</span> <span class="n">affinity</span> <span class="n">domains</span>                    <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">dimensions</span>                        <span class="mi">3</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">sizes</span>                             <span class="mi">1024</span><span class="n">x1024x64</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span>                             <span class="mi">1024</span>
  <span class="n">Preferred</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span> <span class="n">multiple</span>              <span class="mi">32</span>
  <span class="n">Warp</span> <span class="n">size</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                                  <span class="mi">32</span>
  <span class="n">Preferred</span> <span class="o">/</span> <span class="n">native</span> <span class="n">vector</span> <span class="n">sizes</span>
    <span class="n">char</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">short</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="nb">int</span>                                                  <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">long</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">half</span>                                                 <span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span>        <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">float</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">double</span>                                               <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>        <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
  <span class="n">Half</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>           <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Single</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">core</span><span class="p">)</span>
    <span class="n">Denormals</span>                                     <span class="n">Yes</span>
    <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
    <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
    <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
    <span class="n">Correctly</span><span class="o">-</span><span class="n">rounded</span> <span class="n">divide</span> <span class="ow">and</span> <span class="n">sqrt</span> <span class="n">operations</span>  <span class="n">Yes</span>
  <span class="n">Double</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
    <span class="n">Denormals</span>                                     <span class="n">Yes</span>
    <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
    <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
    <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
  <span class="n">Address</span> <span class="n">bits</span>                                    <span class="mi">64</span><span class="p">,</span> <span class="n">Little</span><span class="o">-</span><span class="n">Endian</span>
  <span class="n">Global</span> <span class="n">memory</span> <span class="n">size</span>                              <span class="mi">6373572608</span> <span class="p">(</span><span class="mf">5.936</span><span class="n">GiB</span><span class="p">)</span>
  <span class="n">Error</span> <span class="n">Correction</span> <span class="n">support</span>                        <span class="n">No</span>
  <span class="n">Max</span> <span class="n">memory</span> <span class="n">allocation</span>                           <span class="mi">1593393152</span> <span class="p">(</span><span class="mf">1.484</span><span class="n">GiB</span><span class="p">)</span>
  <span class="n">Unified</span> <span class="n">memory</span> <span class="k">for</span> <span class="n">Host</span> <span class="ow">and</span> <span class="n">Device</span>              <span class="n">No</span>
  <span class="n">Integrated</span> <span class="n">memory</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                          <span class="n">No</span>
  <span class="n">Minimum</span> <span class="n">alignment</span> <span class="k">for</span> <span class="nb">any</span> <span class="n">data</span> <span class="nb">type</span>             <span class="mi">128</span> <span class="nb">bytes</span>
  <span class="n">Alignment</span> <span class="n">of</span> <span class="n">base</span> <span class="n">address</span>                       <span class="mi">4096</span> <span class="n">bits</span> <span class="p">(</span><span class="mi">512</span> <span class="nb">bytes</span><span class="p">)</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="nb">type</span>                        <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">size</span>                        <span class="mi">163840</span> <span class="p">(</span><span class="mi">160</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">line</span> <span class="n">size</span>                   <span class="mi">128</span> <span class="nb">bytes</span>
  <span class="n">Image</span> <span class="n">support</span>                                   <span class="n">Yes</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">samplers</span> <span class="n">per</span> <span class="n">kernel</span>             <span class="mi">32</span>
    <span class="n">Max</span> <span class="n">size</span> <span class="k">for</span> <span class="mi">1</span><span class="n">D</span> <span class="n">images</span> <span class="kn">from</span> <span class="nn">buffer</span>            <span class="mi">134217728</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="mi">1</span><span class="n">D</span> <span class="ow">or</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">array</span> <span class="n">size</span>                 <span class="mi">2048</span> <span class="n">images</span>
    <span class="n">Max</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x32768</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="mi">3</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x16384x16384</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">read</span> <span class="n">image</span> <span class="n">args</span>                 <span class="mi">256</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">write</span> <span class="n">image</span> <span class="n">args</span>                <span class="mi">16</span>
  <span class="n">Local</span> <span class="n">memory</span> <span class="nb">type</span>                               <span class="n">Local</span>
  <span class="n">Local</span> <span class="n">memory</span> <span class="n">size</span>                               <span class="mi">49152</span> <span class="p">(</span><span class="mi">48</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Registers</span> <span class="n">per</span> <span class="n">block</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                        <span class="mi">65536</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">args</span>                     <span class="mi">9</span>
  <span class="n">Max</span> <span class="n">constant</span> <span class="n">buffer</span> <span class="n">size</span>                        <span class="mi">65536</span> <span class="p">(</span><span class="mi">64</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">size</span> <span class="n">of</span> <span class="n">kernel</span> <span class="n">argument</span>                     <span class="mi">4352</span> <span class="p">(</span><span class="mf">4.25</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Queue</span> <span class="n">properties</span>
    <span class="n">Out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">order</span> <span class="n">execution</span>                        <span class="n">Yes</span>
    <span class="n">Profiling</span>                                     <span class="n">Yes</span>
  <span class="n">Prefer</span> <span class="n">user</span> <span class="n">sync</span> <span class="k">for</span> <span class="n">interop</span>                    <span class="n">No</span>
  <span class="n">Profiling</span> <span class="n">timer</span> <span class="n">resolution</span>                      <span class="mi">1000</span><span class="n">ns</span>
  <span class="n">Execution</span> <span class="n">capabilities</span>
    <span class="n">Run</span> <span class="n">OpenCL</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
    <span class="n">Run</span> <span class="n">native</span> <span class="n">kernels</span>                            <span class="n">No</span>
    <span class="n">Kernel</span> <span class="n">execution</span> <span class="n">timeout</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                 <span class="n">No</span>
  <span class="n">Concurrent</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">kernel</span> <span class="n">execution</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>       <span class="n">Yes</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="k">async</span> <span class="n">copy</span> <span class="n">engines</span>                  <span class="mi">2</span>
  <span class="n">printf</span><span class="p">()</span> <span class="n">buffer</span> <span class="n">size</span>                            <span class="mi">1048576</span> <span class="p">(</span><span class="mi">1024</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Built</span><span class="o">-</span><span class="ow">in</span> <span class="n">kernels</span>                                <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Device</span> <span class="n">Extensions</span>                               <span class="n">cl_khr_global_int32_base_atomics</span> <span class="n">cl_khr_global_int32_extended_atomics</span> <span class="n">cl_khr_local_int32_base_atomics</span> <span class="n">cl_khr_local_int32_extended_atomics</span> <span class="n">cl_khr_fp64</span> <span class="n">cl_khr_byte_addressable_store</span> <span class="n">cl_khr_icd</span> <span class="n">cl_khr_gl_sharing</span> <span class="n">cl_nv_compiler_options</span> <span class="n">cl_nv_device_attribute_query</span> <span class="n">cl_nv_pragma_unroll</span> <span class="n">cl_nv_copy_opts</span> <span class="n">cl_nv_create_buffer</span>
</pre></div>
</div>
<p><strong>AMD GPU</strong></p>
<p>AMD has very good support for OpenCL but I haven’t had an AMD GPU for testing.</p>
<p><strong>Open-source Intel Compute OpenCL (Beignet and NEO)</strong></p>
<p>Benoit provides some instructions for using the open-source opencl driver <cite>beignet</cite>. A recent open-source Intel OpenCL <cite>neo</cite> (see <cite>https://github.com/intel/compute-runtime</cite>) may be useful.</p>
</div>
</div>
</div>
</div>
<span id="document-versionhistory"></span><div class="section" id="version-history">
<h2>Version history<a class="headerlink" href="#version-history" title="Permalink to this headline">¶</a></h2>
<p><strong>v2020.1.0</strong></p>
<ul class="simple">
<li><p>add batch mode to nudft_cpu</p></li>
</ul>
<p><strong>v2020.0.0</strong></p>
<ul class="simple">
<li><p>fix batch=1. This can cause error in Riekna fft.</p></li>
</ul>
<p><strong>v2019.2.3</strong></p>
<p>-(experimental) Add the unified NUFFT() class. Now CPU, GPU, and legacy GPU mode are encapsuled in a single class.</p>
<p>-Tested using Intel Neo OpenCL driver (see <a class="reference external" href="https://github.com/intel/compute-runtime">https://github.com/intel/compute-runtime</a>) and IntelPython3.</p>
<p>-The old NUFFT_cpu() and NUFFT_legacy() will be kept in the system for compatibility.</p>
<p><strong>v2019.2.1-2019.2.2</strong></p>
<p>-Remove lsmr as scipy 1.13 has caused unknown error.</p>
<p><strong>v2019.2.0</strong></p>
<ul class="simple">
<li><p>Bump</p></li>
</ul>
<p><strong>v2019.1.2</strong></p>
<ul class="simple">
<li><p>BUGFIX: fix the loss of accuracy in cSpmvh(). Replace the group/local by global memory (the group/local sizes have caused the unknown run-time behaviour on cuda)</p></li>
</ul>
<p><strong>v2019.1.1</strong></p>
<ul class="simple">
<li><p>Refactor the re_subroutine.py</p></li>
<li><p>Adopt tensor form</p></li>
</ul>
<p><strong>v0.4.0.0</strong></p>
<ul class="simple">
<li><p>0.4.0.0 is a beta version.</p></li>
<li><p>Major updates for the NUFFT_hsa class, including memory reduction and split-radix. Multiple NUFFT_hsa() using cuda backend becomes possible, by pushing the context to the top of the stack when a method is called.</p></li>
<li><p>Tested in Windows 10 with PyCUDA 2018.1.1, nvidia-driver 417.35, CUDA 9.2, Visual Studio 2015 Community, and Anaconda Python 3.7 64-bit. PyOpenCL in Windows is yet to be tested.</p></li>
<li><p>Add batch mode.</p></li>
</ul>
<p><strong>v0.3.3.12</strong></p>
<ul class="simple">
<li><p>0.3.3.12 is a bug-fixed version.</p></li>
<li><p>Removal of the keyword async for compatibility reasons because Reikna has changed the keyword to <a href="#id1"><span class="problematic" id="id2">async_</span></a>.</p></li>
</ul>
<p><strong>v0.3.3.8</strong></p>
<ul class="simple">
<li><p>Bugfix: mm = numpy.tile(mm, [numpy.prod(Jd).astype(int), 1])  to fix the wrong type when numpy.prod(Jd) is not cast as int</p></li>
<li><p>Bugfix: fix rcond=None error in Anaconda 3.6.5 and Numpy 1.13.1 (the recommended None in Numpy 1.14 is backward incompatible with 1.13)</p></li>
<li><p>Bugfix:  indx1 = indx.copy() is replaced by indx1 = list(indx) for Python2 compatibility</p></li>
</ul>
<p><strong>v0.3.3.7</strong></p>
<ul class="simple">
<li><p>Bugfix in 0.3.3.7 Toeplitz is removed from the NUFFT_cpu and NUFFT_gpu to avoid the MemoryError.</p></li>
</ul>
<p><strong>v0.3.3.6</strong></p>
<ul class="simple">
<li><p>Bugfix: correct the error of import. Now import NUFFT_cpu, NUFFT_hsa at the top level.</p></li>
</ul>
<p><strong>v0.3.3</strong></p>
<ul class="simple">
<li><p>Note: GPU support is superseded by Heterogeneous System Architecture (HSA).</p></li>
<li><p>A variety of nonlinear solvers are provided, including the conjugate gradient method (cg), L1 total-variation ordinary least square (L1TVOLS), and L1 total-variation least absolute deviation (L1TVLAD).</p></li>
<li><p>The CPU version support other nonlinear solvers, lsqr, gmr, cg, bicgstab, bicg, cgs, gmres, lgmres , apart from cg, L1TVOLS and L1TVLAD.</p></li>
<li><p>Support multi-dimensional transform and reconstruction (experimentally).</p></li>
</ul>
<p><strong>v0.3.2.9</strong></p>
<ul class="simple">
<li><p>Experimental support of NVIDIA’s graphic processing unit (GPU).</p></li>
<li><p>The experimental class gpuNUFFT requires pycuda, scikit-cuda, and python-cuda-cffi. scikit-cuda can be installed from standard command.</p></li>
</ul>
<p><strong>v0.3.2.8</strong></p>
<ul class="simple">
<li><p>Tested under Linux and Windows Anaconda3</p></li>
</ul>
<p><strong>v0.3</strong></p>
<ul class="simple">
<li><p>Updated setup.py</p></li>
<li><p>Removal of pyfftw due to segfault under some Linux distributions</p></li>
</ul>
</div>
<span id="document-acknow/init"></span><div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>I would be more than grateful for what
contributors have done (either contributing codes or fixing bugs in pynufft).
However, The information of contributors and partners are kept anonymized without
their prior express informed consent.
If anyone would like to be identified as a contributors/partners, please contact <a class="reference external" href="mailto:pynufft&#37;&#52;&#48;gmail&#46;com">pynufft<span>&#64;</span>gmail<span>&#46;</span>com</a>.</p>
<p><strong>Financial supports</strong></p>
<p>Cambridge Commonwealth, European and International Trust (Cambridge, UK)</p>
<p>Ministry of Education (Taiwan)</p>
<p>NVIDIA Corp for donating Titan X Pascal.</p>
<p>The * project (The <a href="#id1"><span class="problematic" id="id2">*</span></a>, * and <a href="#id3"><span class="problematic" id="id4">*</span></a>)</p>
<p>The * project</p>
<p><strong>Contributors and partners</strong></p>
<p>R******</p>
<p>T******</p>
<p>H******</p>
<p>J******</p>
<p>W*****</p>
<p>I******</p>
<p>A*****</p>
<p>A*****</p>
<p>B*****</p>
<p>D******</p>
<p>M*****</p>
<p>C******</p>
<p>C*****</p>
<p>J*****</p>
<p>J******</p>
<p>The <strong>*</strong> project (The <a href="#id5"><span class="problematic" id="id6">*</span></a>, * and <a href="#id7"><span class="problematic" id="id8">*</span></a>)</p>
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="contact-information">
<h2>Contact information<a class="headerlink" href="#contact-information" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="mailto:pynufft&#37;&#52;&#48;gmail&#46;com">pynufft<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</div>
</div>


          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">PyNUFFT 2020.1.0  documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2012-2020, PyNUFFT services. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>