
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>PyNUFFT 2020.2.1 documentation</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="#">PyNUFFT 2020.2.1  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PyNUFFT 2020.2.1  documentation</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-overview/init">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/pynufft">The Python Non-uniform fast Fourier transform (PyNUFFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/Nd_NUFFT">Multi-dimensional NUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-overview/CPU_GPU">CPU and GPU (HSA)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutor/init">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/basic_use">Basic use of PyNUFFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/example">The 1D example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/more2D">The 2D example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-tutor/more3D">A 3D example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-manu/init">Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/multiple_NUFFT">Multiple NUFFT instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#multiprocessing-experimental">Multiprocessing (experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-manu/realistic_om">k-Space trajectories (om)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-API/init">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#nufft-class">NUFFT class</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cpu-solvers">CPU solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#hsa-solvers">HSA solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nudft-class">NUDFT class</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#helper-functions">Helper functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#metaprogramming-subroutines-using-reikna-pyopencl-pycuda">Metaprogramming subroutines (using reikna, pyopencl, pycuda)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-installation/init">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#system-requirements">System requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#software">Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#general-installation">General Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#special-topics">Special topics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-versionhistory">Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-acknow/init">Acknowledgements</a></li>
</ul>

    </div>
  </div>
</div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="#">Docs</a></li>
              
              <li>PyNUFFT 2020.2.1  documentation</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="welcome-to-pynufft-s-user-manual">
<h1>Welcome to PyNUFFT’s User Manual!<a class="headerlink" href="#welcome-to-pynufft-s-user-manual" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-overview/init"></span><div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-overview/pynufft"></span><div class="section" id="the-python-non-uniform-fast-fourier-transform-pynufft">
<h3>The Python Non-uniform fast Fourier transform (PyNUFFT)<a class="headerlink" href="#the-python-non-uniform-fast-fourier-transform-pynufft" title="Permalink to this headline">¶</a></h3>
<p><strong>Purpose</strong></p>
<p>The PyNUFFT user manual documents the <em>Python non-uniform fast Fourier transform</em>, a Python package for non-uniform fast Fourier transform.</p>
<p>PyNUFFT was created for fun. The content may not reflect the views of funding bodies, former or current partners, and contributors.</p>
<p>If you find PyNUFFT useful, please cite:</p>
<p><em>Lin, Jyh-Miin. “Python Non-Uniform Fast Fourier Transform (PyNUFFT): An Accelerated Non-Cartesian MRI Package on a Heterogeneous Platform (CPU/GPU).” Journal of Imaging 4.3 (2018): 51.</em></p>
<p>or</p>
<p><em>J.-M. Lin and H.-W. Chung, Pynufft: python non-uniform fast Fourier transform for MRI Building Bridges in Medical Sciences 2017, St John’s College, CB2 1TP Cambridge, UK</em></p>
<p>Users of PyNUFFT should be familiar with discrete Fourier transform (DFT).</p>
<p><strong>The min-max interpolator</strong></p>
<ul class="simple">
<li><p>PyNUFFT translates the min-max interpolator to Python. The min-max interpolator is described in the literature:</p></li>
</ul>
<p><em>Fessler JA, Sutton BP. Nonuniform fast Fourier transforms using min-max interpolation. IEEE Trans Signal Process 2003;51(2):560-574.</em></p>
<p><strong>Current status of PyNUFFT</strong></p>
<ul class="simple">
<li><p>The current PyNUFFT relies on Numpy/Scipy (NUFFT_cpu) and Reikan/PyCUDA/PyOpenCL (NUFFT_hsa).</p></li>
<li><p>A single NUFFT class. Switch between CPU and GPU by selecting device = pynufft.helper.device_list[0]</p></li>
<li><p>LGPLv3 and AGPL (for web service)</p></li>
</ul>
</div>
<span id="document-overview/Nd_NUFFT"></span><div class="section" id="multi-dimensional-nufft">
<h3>Multi-dimensional NUFFT<a class="headerlink" href="#multi-dimensional-nufft" title="Permalink to this headline">¶</a></h3>
<p>Multi-dimensional transforms are supported by PyNUFFT.</p>
<p>The dimensionality of an imaging reconstruction problem is revealed as
the number of axes of the Nd (or Kd, Jd) tuples.</p>
<p>For example, Nd = (256,256) indicates a 2D imaging reconstruction problem,
in which the sizes of the x-y axes are 256 and 256, respectively.</p>
<p>Normally, the matrix size of the k-space is twice the size of Nd. For example,
Kd = (512,512) is appropriate for the above Nd = (256,256) problem.</p>
<p>In batch mode, the ‘batch’ argument controls the number of channels.
This will not affect the dimensionality of the image reconstruction problem.
The batch model will be detailed in the ‘batched NUFFT’ section.</p>
<p><a class="reference internal" href="#configuration-nufft"><span class="std std-numref">Fig. 1</span></a> illustrates the variables for 1D, 2D, 3D NUFFT.</p>
<div class="figure align-default" id="id1">
<span id="configuration-nufft"></span><a class="reference internal image-reference" href="_images/configuration_nufft.png"><img alt="_images/configuration_nufft.png" src="_images/configuration_nufft.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Configuration of 1D, 2D, and 3D NUFFT.
(A) 1D NUFFT: om is a numpy.array of the shape (M,1).
M is the number of non-Cartesian points.
Nd = (8, ) is the image domain grid size and Kd = (16, ) is the oversampled grid size.
Jd = (6, ) is the interpolator size.
(B) 2D NUFFT: om is a numpy.array of the shape (M,2).
M is the number of non-Cartesian points.
Nd = (8, 8 ) is the image domain grid size and Kd = (16, 16 ) is the oversampled grid size.
Jd = (6, 6 ) is the interpolator size.
(C) 3D NUFFT: om is a numpy.array of the shape (M,3).
M is the number of non-Cartesian points.
Nd = (8, 8, 8 ) is the image domain grid size and Kd = (16, 16, 16 ) is the oversampled grid size.
Jd = (6, 6, 6 ) is the interpolator size.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<span id="document-overview/CPU_GPU"></span><div class="section" id="cpu-and-gpu-hsa">
<h3>CPU and GPU (HSA)<a class="headerlink" href="#cpu-and-gpu-hsa" title="Permalink to this headline">¶</a></h3>
<p>The PyNUFFT ran originally on Numpy/Scipy. Unfortunately the default Numpy/Scipy is most efficient on a single CPU core.</p>
<p>Later it was ported to PyCUDA and PyOpenCL, which allows us to leverage the speed of multi-core CPU and GPU.</p>
<p>Mixing NUFFT_cpu and NUFFT_hsa, or multiple NUFFT_cpu or multiple NUFFT_hsa is possible but has no warranty.</p>
<p>The class methods are listed in <a class="reference internal" href="#dimension-table"><span class="std std-numref">Table 1</span></a></p>
<span id="dimension-table"></span><table class="colwidths-given docutils align-default" id="id1">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Methods implemented in NUFFT</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>method name</p></th>
<th class="head"><p>NUFFT()</p></th>
<th class="head"><p>NUFFT(helper.device_list[number])</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__init__()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Constructor</p></td>
</tr>
<tr class="row-odd"><td><p>plan()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Planning the instance</p></td>
</tr>
<tr class="row-even"><td><p>forward()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Forward NUFFT <span class="math notranslate nohighlight">\(A\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>adjoint()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Adjoint NUFFT <span class="math notranslate nohighlight">\(A^H\)</span></p></td>
</tr>
<tr class="row-even"><td><p>offload()</p></td>
<td><p>×</p></td>
<td><p>✓</p></td>
<td><p>Offload the NUFFT_hsa() to device.</p></td>
</tr>
<tr class="row-odd"><td><p>x2xx()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Apply the scaling factor</p></td>
</tr>
<tr class="row-even"><td><p>xx2k()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Oversampled FFT</p></td>
</tr>
<tr class="row-odd"><td><p>k2y()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Interpolation</p></td>
</tr>
<tr class="row-even"><td><p>k2vec()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>Reshape the k-space to the vector</p></td>
</tr>
<tr class="row-odd"><td><p>vec2y()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>Multiply the vector to generate the data</p></td>
</tr>
<tr class="row-even"><td><p>vec2k()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>Reshape the vector to k-space</p></td>
</tr>
<tr class="row-odd"><td><p>y2vec()</p></td>
<td><p>✓</p></td>
<td><p>×</p></td>
<td><p>Multiply the data to get the vector</p></td>
</tr>
<tr class="row-even"><td><p>y2k()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Adjoint of k2y()</p></td>
</tr>
<tr class="row-odd"><td><p>k2xx()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Inverse FFT (excessive parts are cropped)</p></td>
</tr>
<tr class="row-even"><td><p>xx2x()</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Apply the scaling factor</p></td>
</tr>
<tr class="row-odd"><td><p>_precompute</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Apply the scaling factor</p></td>
</tr>
</tbody>
</table>
<div class="section" id="parameters-of-pynufft">
<h4>Parameters of PyNUFFT<a class="headerlink" href="#parameters-of-pynufft" title="Permalink to this headline">¶</a></h4>
<p>Below we summarize the required variables in <a class="reference internal" href="#parameter-table"><span class="std std-numref">Table 2</span></a></p>
<span id="parameter-table"></span><table class="colwidths-given docutils align-default" id="id2">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Parameters of the plan() method</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>NUFFT_cpu</p></th>
<th class="head"><p>NUFFT_hsa</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>om (Numpy Array)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Non-Cartesian coordinates (M, dim)</p></td>
</tr>
<tr class="row-odd"><td><p>Nd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the image grid</p></td>
</tr>
<tr class="row-even"><td><p>Kd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the oversampled Fourier grid</p></td>
</tr>
<tr class="row-odd"><td><p>Jd (tuple)</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>Size of the interpolator</p></td>
</tr>
<tr class="row-even"><td><p>ft_axes (tuple)</p></td>
<td><p>optional</p></td>
<td><p>optional</p></td>
<td><p>FFT on the given axes (default = None (all axes))</p></td>
</tr>
<tr class="row-odd"><td><p>batch (int)</p></td>
<td><p>optional</p></td>
<td><p>optional</p></td>
<td><p>Batch NUFFT (default = None)</p></td>
</tr>
<tr class="row-even"><td><p>radix (int)</p></td>
<td><p>×</p></td>
<td><p>optional</p></td>
<td><p>radix (default = 1)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<span id="document-tutor/init"></span><div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-tutor/basic_use"></span><div class="section" id="basic-use-of-pynufft">
<h3>Basic use of PyNUFFT<a class="headerlink" href="#basic-use-of-pynufft" title="Permalink to this headline">¶</a></h3>
<p>This section navigates you through the basic use of PyNUFFT.</p>
<div class="section" id="initiating-a-pynufft-object">
<h4>Initiating a PyNUFFT object<a class="headerlink" href="#initiating-a-pynufft-object" title="Permalink to this headline">¶</a></h4>
<p>We can initiate a PyNUFFT by importing the NUFFT object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># import NUFFT class</span>
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>

<span class="c1"># Initiate the NufftObj object</span>
<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
<p>The NufftObj object has been created but at this point it is still empty.</p>
<p>Now we have to plan the NufftObj by calling the plan() method.
The plan() method takes the input variables and plans for the object.
Now we can plan for the NufftObj object given the non-Cartesian coordinates (om).</p>
<p>In the following code we have 100 random samples spreading across the 2D plane.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># generating 2D random coordinates</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="plan-for-the-nufft-object">
<h4>Plan for the NUFFT object<a class="headerlink" href="#plan-for-the-nufft-object" title="Permalink to this headline">¶</a></h4>
<p>Now we call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>See :py:class: <cite>pynufft.NUFFT</cite></p>
</div>
<div class="section" id="forward-nufft">
<h4>Forward NUFFT<a class="headerlink" href="#forward-nufft" title="Permalink to this headline">¶</a></h4>
<p>The forward NUFFT transforms the image into non-Cartesian samples.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>The image.shape is equal to Nd. The returned y has a shape which is equal to (M, )</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">pynufft.NUFFT.forward()</span></code></p>
</div>
<div class="section" id="adjoint-nufft">
<h4>Adjoint NUFFT<a class="headerlink" href="#adjoint-nufft" title="Permalink to this headline">¶</a></h4>
<p>The adjoint NUFFT transforms the non-Cartesian samples into the image</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>y has a shape which is equal to (M, ). The returned image.shape is equal to Nd.</p>
</div>
</div>
<span id="document-tutor/example"></span><div class="section" id="the-1d-example">
<h3>The 1D example<a class="headerlink" href="#the-1d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
</pre></div>
</div>
<p>Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Planning</strong></p>
<p>The <span class="math notranslate nohighlight">\(M\)</span> locations of the non-uniform samples (<span class="math notranslate nohighlight">\(om\)</span>) must be provided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1512</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># om is an M x 1 ndarray: locations of M points. *om* is normalized between [-pi, pi]</span>
<span class="c1"># Here M = 1512</span>
</pre></div>
</div>
<p>In addition, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>) are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</pre></div>
</div>
<p>Now provide NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. Continue with an example.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="n">time_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">)</span>
<span class="n">time_data</span><span class="p">[</span><span class="mi">96</span><span class="p">:</span><span class="mi">128</span><span class="o">+</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This generates a time series <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>.</p>
<div class="figure align-default" id="id1">
<span id="box-function"></span><a class="reference internal image-reference" href="_images/box_function.png"><img alt="_images/box_function.png" src="_images/box_function.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">A box function time series</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nufft_freq_data</span> <span class="o">=</span><span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">time_data</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">,</span><span class="n">nufft_freq_data</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;imag&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This displays the non-Cartesian spectrum <a class="reference internal" href="#non-cartesian-spectrum"><span class="std std-numref">Fig. 3</span></a>.</p>
<div class="figure align-default" id="id2">
<span id="non-cartesian-spectrum"></span><a class="reference internal image-reference" href="_images/non_Cartesian_spectrum.png"><img alt="_images/non_Cartesian_spectrum.png" src="_images/non_Cartesian_spectrum.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Non-Cartesian spectrum of box function in <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>. Note the non-uniform density.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Signal restoration through “solve()”</strong></p>
<p>The signal can be solved by the solve() method</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">restore_time</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">restore_time2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nufft_freq_data</span><span class="p">,</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now display the restored signals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">im1</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_data</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">)</span>
<span class="n">im3</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time2</span><span class="p">),</span><span class="s1">&#39;k--&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">)</span>
<span class="n">im4</span><span class="p">,</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restore_time</span><span class="p">),</span><span class="s1">&#39;r:&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;conjugate_gradient_method&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">im1</span><span class="p">,</span> <span class="n">im3</span><span class="p">,</span><span class="n">im4</span><span class="p">])</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id3">
<span id="solve"></span><a class="reference internal image-reference" href="_images/script_1D_solve.png"><img alt="_images/script_1D_solve.png" src="_images/script_1D_solve.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Signals restored by “solve()”. L1TVOLS and L1TVOLS are close to <a class="reference internal" href="#box-function"><span class="std std-numref">Fig. 2</span></a>, whereas cg is subject to distortion.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The complete code is:</p>
</div>
<span id="document-tutor/more2D"></span><div class="section" id="the-2d-example">
<h3>The 2D example<a class="headerlink" href="#the-2d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module and other packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
</pre></div>
</div>
<p><strong>Loading the X-Y locations(“om”)</strong></p>
<p>It requires the x-y coordinates of <span class="math notranslate nohighlight">\(M\)</span> points to plan NufftObj.</p>
<p>A 2D trajectory from my PROPELLER MRI research is provided in the pynufft package.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="o">+</span><span class="s1">&#39;om2D.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(M\)</span> locations of non-uniform samples (<span class="math notranslate nohighlight">\(om\)</span>) forms an M x 2 numpy.ndarray</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="p">)</span>

<span class="p">[[</span><span class="o">-</span><span class="mf">3.12932086</span>  <span class="mf">0.28225246</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.1047771</span>   <span class="mf">0.28225246</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.08023357</span>  <span class="mf">0.28225246</span><span class="p">]</span>
 <span class="o">....</span>
<span class="p">[</span><span class="o">-</span><span class="mf">2.99815702</span>  <span class="mf">0.76063216</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.02239823</span>  <span class="mf">0.76447165</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.04663992</span>  <span class="mf">0.76831114</span><span class="p">]]</span>
</pre></div>
</div>
<p>You can see the 2D <span class="math notranslate nohighlight">\(M\)</span> locations by plotting <span class="math notranslate nohighlight">\(x\)</span> versus <span class="math notranslate nohighlight">\(y\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">om</span><span class="p">[::</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;non-uniform coordinates&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;axis 0&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;axis 1&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>As can be seen in <a class="reference internal" href="#propeller-trajectory"><span class="std std-numref">Fig. 5</span></a>:</p>
<div class="figure align-default" id="id1">
<span id="propeller-trajectory"></span><a class="reference internal image-reference" href="_images/propeller_trajectory.png"><img alt="_images/propeller_trajectory.png" src="_images/propeller_trajectory.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">The 2D PROPELLER trajectory of M points.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Planning</strong>
Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
<p>Provided <span class="math notranslate nohighlight">\(om\)</span>, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>  <span class="c1"># image size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting image dimension Nd...&#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>  <span class="c1"># k-space size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting spectrum dimension Kd...&#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># interpolation size</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting interpolation size Jd...&#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can plan NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. We continue with an example.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading image...&#39;</span><span class="p">)</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This displays the image <a class="reference internal" href="#d-example-image"><span class="std std-numref">Fig. 6</span></a>.</p>
<div class="figure align-default" id="id2">
<span id="d-example-image"></span><a class="reference internal image-reference" href="_images/2d_example_image.png"><img alt="_images/2d_example_image.png" src="_images/2d_example_image.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">The 2D image from scipy.misc.ascent()</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Image restoration with solve()</strong>:</p>
<p>The image can be restored from non-Cartesian samples y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image0</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">image3</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">image2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">y</span> <span class="p">)</span> <span class="c1"># adjoint</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image (cg)&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image0</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image2</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Adjoint transform&#39;</span><span class="p">)</span>


<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TV OLS&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image3</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id3">
<span id="d-restore"></span><a class="reference internal image-reference" href="_images/2D_restoration.png"><img alt="_images/2D_restoration.png" src="_images/2D_restoration.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Image restoration through solve() ‘cg’, ‘L1TVOLS’, ‘L1TVLAD’ and adjoint().</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The spectrum of the restored image:</p>
<div class="figure align-default" id="id4">
<span id="d-spectrum"></span><a class="reference internal image-reference" href="_images/2D_spectrum.png"><img alt="_images/2D_spectrum.png" src="_images/2D_spectrum.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">The spectrum of the restored image solved by cg.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</div>
<span id="document-tutor/more3D"></span><div class="section" id="a-3d-example">
<h3>A 3D example<a class="headerlink" href="#a-3d-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Import pynufft module</strong></p>
<p>In python environment, import pynufft module and other packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
</pre></div>
</div>
<p><strong>Planning</strong></p>
<p>Create a pynufft object NufftObj:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
<p>Provided <span class="math notranslate nohighlight">\(om\)</span>, the size of time series (<span class="math notranslate nohighlight">\(Nd\)</span>), oversampled grid (<span class="math notranslate nohighlight">\(Kd\)</span>), and interpolatro size (<span class="math notranslate nohighlight">\(Jd\)</span>) are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="c1"># time grid, tuple</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="c1"># frequency grid, tuple</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># interpolator</span>
<span class="c1">#     om=       numpy.load(DATA_PATH+&#39;om3D.npz&#39;)[&#39;arr_0&#39;]</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">15120</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can plan NufftObj with these parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Forward transform</strong></p>
<p>Now NufftObj has been prepared and is ready for computations. Continue with an example, as follows.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;pynufft&#39;</span><span class="p">,</span> <span class="s1">&#39;./src/data/&#39;</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span> <span class="o">+</span><span class="s1">&#39;phantom_3D_128_128_128.npz&#39;</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">special_license</span><span class="p">)</span>
</pre></div>
</div>
<p>This displays the image <a class="reference internal" href="#d-example-image"><span class="std std-numref">Fig. 9</span></a>.</p>
<div class="figure align-default" id="id1">
<span id="d-example-image"></span><a class="reference internal image-reference" href="_images/3D_phantom1.png"><img alt="_images/3D_phantom1.png" src="_images/3D_phantom1.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">The 3D phantom</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>NufftObj transform the time_data to non-Cartesian locations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Image restoration with solve()</strong>:</p>
<p>The image can be restored from non-Cartesian samples y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">restore_image</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kspace</span><span class="p">,</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

<span class="c1">#</span>
<span class="n">restore_image2</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kspace</span><span class="p">,</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;original signal&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;original&#39;</span><span class="p">)</span>

<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">restore_image2</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;L1TVOLS&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">restore_image</span><span class="p">[:,:,</span><span class="mi">32</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;CG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-default" id="id2">
<span id="d-restore"></span><a class="reference internal image-reference" href="_images/3D_restore1.png"><img alt="_images/3D_restore1.png" src="_images/3D_restore1.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Image restoration using’cg’, ‘L1TVOLS’.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
</div>
<span id="document-manu/init"></span><div class="section" id="manual">
<h2>Manual<a class="headerlink" href="#manual" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-manu/multiple_NUFFT"></span><div class="section" id="multiple-nufft-instances">
<h3>Multiple NUFFT instances<a class="headerlink" href="#multiple-nufft-instances" title="Permalink to this headline">¶</a></h3>
<p>Multiple NUFFT instances (of mixed types) can coexist at the same time.
Each instance has its own memory.
However,  multiple instances  may be penalized by hardware and reduced runtime speed.</p>
<p>Multiple instances can be planned after all the instances have been created.
Alternatively, each instance can be planned immediately after being created.</p>
<p>Note that multiple PyCUDA instances were made possible since 2019.1.1,
by introducing the push_cuda_context() decorating function.
Versions earlier than 2019.1.1 do not support multiple PyCUDA backends.
This is because every call to a CUDA context will require the current
context to pop up to the top of the stack of the contexts.</p>
<p>PyOpenCL does not have the context pop-up issue but please always use the newest version.</p>
<p><strong>Multiple NUFFT instances</strong></p>
<p>Multiple instances can be planned after all the instances have been created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="c1"># Create the second NUFFT</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="c1"># Plan the first instance</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>or each instance can be planned once it has been created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="c1"># Create the second NUFFT</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">NufftObj1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">NufftObj2</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Multiple NUFFT_hsa instances</strong></p>
<p>Like NUFFT_cpu, each instance can be planned immediately after being created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the first NUFFT</span>
<span class="n">NufftObj1</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">(</span><span class="n">helper</span><span class="o">.</span><span class="n">device_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">NufftObj1</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om1</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="c1"># Create the second NUFFT_hsa</span>
<span class="n">NufftObj2</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">(</span><span class="n">helper</span><span class="o">.</span><span class="n">device_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">NufftObj2</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">NufftObj1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">NufftObj2</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="multiprocessing-experimental">
<h3>Multiprocessing (experimental)<a class="headerlink" href="#multiprocessing-experimental" title="Permalink to this headline">¶</a></h3>
<p>The multiprocessing module is the built-in parallel method of C-Python.
PyNUFFT may (experimentally) work together with the multiprocessing
module of Python.</p>
<p>The mutliprocessing module relies on pickle to serialize the data, whereas
the PyCUDA and PyOpenCL contexts are “unpicklable”.
Thus, I found that multiprocessing for PyNUFFT must fulfil the following conditions: (1)
each NUFFT instance should be created and then executed in a separate process;
(2) any CUDA/PyOpenCL related object cannot be sent or planned in advance, and
(3) taskset should be used to assign a process to a specified CPU core.</p>
<p>It is the user’s responsibility to take care of the hardware (total memory and IO).</p>
<p>One example of working with multiprocessing (mixed CUDA and OpenCL backends) is as follows.
In this example, an “atomic_NUFFT” class is created as a high-level wrapper for the creation and execution of NUFFT.
This example has only been tested in Linux because parallel computing is highly platform dependent.</p>
</div>
<span id="document-manu/realistic_om"></span><div class="section" id="k-space-trajectories-om">
<h3>k-Space trajectories (om)<a class="headerlink" href="#k-space-trajectories-om" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cartesian-k-space">
<h4>Cartesian k-space<a class="headerlink" href="#cartesian-k-space" title="Permalink to this headline">¶</a></h4>
<p>This section aims to provide a good example to show that NUFFT can be used to compute many different trajectories, including the Cartesian k-space.</p>
<p>However, Cartesian k-space should mostly be computed by FFT and this section is provided only for testing.</p>
<p>In the example, we generate a PyNUFFT object and make a plan using Cartesian k-space, followed by the NUFFT transform.</p>
<p>The data is created by NUFFT but on the Cartesian grid.</p>
<p>Last the Cartesian data are transformed back to image by IFFT (with two ifftshifts before and after ifftn):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating trajectories for Cartesian k-space</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">):</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span> <span class="c1"># dimension</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dimid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="n">om</span><span class="p">[:,</span> <span class="n">dimid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">dimid</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span><span class="mi">2</span><span class="o">/</span> <span class="n">Nd</span><span class="p">[</span><span class="n">dimid</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">om</span>

<span class="kn">import</span> <span class="nn">scipy.misc</span>

<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_cpu</span>


<span class="n">Nd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span>
<span class="n">Kd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
<span class="n">Jd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">fake_Cartesian</span><span class="p">(</span><span class="n">Nd</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of samples (M) = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dimension = &#39;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nd = &#39;</span><span class="p">,</span> <span class="n">Nd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Kd = &#39;</span><span class="p">,</span> <span class="n">Kd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Jd = &#39;</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>

<span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">NufftObj</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">y2</span><span class="p">)))</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original image&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Restored image&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">x2</span><span class="p">),</span> <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Difference map&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>As you can see, the resulting images (<a class="reference internal" href="#fake-cartesian"><span class="std std-numref">Fig. 11</span></a>) confirm that NUFFT + IFFT can restore the original image.</p>
<div class="figure align-default" id="id1">
<span id="fake-cartesian"></span><a class="reference internal image-reference" href="_images/fake_Cartesian.png"><img alt="_images/fake_Cartesian.png" src="_images/fake_Cartesian.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">A Cartesian example generates the contrived Cartesian data using NUFFT, followed by IFFT.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="radial-k-space">
<h4>Radial k-space<a class="headerlink" href="#radial-k-space" title="Permalink to this headline">¶</a></h4>
<p>We can generate the radial spokes on the 2D plane.
Each radial spoke spans the range of  <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> at the angle <span class="math notranslate nohighlight">\(\theta\)</span> and each point is fully determined by the  polar coordinate (R, <span class="math notranslate nohighlight">\(\theta\)</span>).
See <a class="reference internal" href="#radial-spoke"><span class="std std-numref">Fig. 12</span></a> for more information.</p>
<div class="figure align-default" id="id2">
<span id="radial-spoke"></span><a class="reference internal image-reference" href="_images/radial_spoke.png"><img alt="_images/radial_spoke.png" src="_images/radial_spoke.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Illustration of five radial spokes.
Each point of the spoke can be described by the polar coordinate (R, <span class="math notranslate nohighlight">\(\theta\)</span>),
which can be transformed to Cartesian coordinates (R cos(<span class="math notranslate nohighlight">\(\theta\)</span>), R sin(<span class="math notranslate nohighlight">\(\theta\)</span>)).</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>The following code generates 360 radial spokes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># generating 2D radial coordinates</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">spoke_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span> <span class="o">-</span> <span class="mf">256.0</span> <span class="p">)</span><span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span> <span class="mi">256</span>  <span class="c1"># normalized between -pi and pi</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">512</span><span class="o">*</span><span class="mi">360</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


<span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">):</span>
   <span class="n">radian</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span> <span class="mf">360.0</span>
   <span class="n">spoke_x</span> <span class="o">=</span>  <span class="n">spoke_range</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radian</span><span class="p">)</span>
   <span class="n">spoke_y</span> <span class="o">=</span>  <span class="n">spoke_range</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radian</span><span class="p">)</span>
   <span class="n">om</span><span class="p">[</span><span class="mi">512</span><span class="o">*</span><span class="n">angle</span> <span class="p">:</span> <span class="mi">512</span><span class="o">*</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spoke_x</span>
   <span class="n">om</span><span class="p">[</span><span class="mi">512</span><span class="o">*</span><span class="n">angle</span> <span class="p">:</span> <span class="mi">512</span><span class="o">*</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spoke_y</span>


<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">om</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">om</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<span id="document-API/init"></span><div class="section" id="module-pynufft.nufft.__init__">
<span id="api-documentation"></span><h2>API documentation<a class="headerlink" href="#module-pynufft.nufft.__init__" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nufft-class">
<h3>NUFFT class<a class="headerlink" href="#nufft-class" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="pynufft.nufft.__init__.NUFFT">
<em class="property">class </em><code class="sig-prename descclassname">pynufft.nufft.__init__.</code><code class="sig-name descname">NUFFT</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">device_indx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">legacy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT" title="Permalink to this definition">¶</a></dt>
<dd><p>A super class of cpu and gpu NUFFT functions.</p>
<p>Note: NUFFT does not inherit NUFFT_cpu (deprecated) and NUFFT_hsa (deprecated).</p>
<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">device_indx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">legacy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python NoneType</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NUFFT: the pynufft.NUFFT instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NUFFT: the pynufft.NUFFT class</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span><span class="p">,</span> <span class="n">helper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">device</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">device_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="c1"># for first acceleration device in the system</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.nufft.__init__.NUFFT.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._adjoint_cpu">
<code class="sig-name descname">_adjoint_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._adjoint_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> – The input numpy array, with the size of (M,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array,
with the size of Nd or Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._adjoint_device">
<code class="sig-name descname">_adjoint_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._adjoint_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gy</strong> – The input gpu array, with size=(M,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._adjoint_legacy">
<code class="sig-name descname">_adjoint_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._adjoint_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gy</strong> – The input gpu array, with size=(M,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._forward_cpu">
<code class="sig-name descname">_forward_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._forward_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with the size of Nd</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>y: The output numpy array, with the size of (M,)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._forward_device">
<code class="sig-name descname">_forward_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._forward_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype = numpy.complex64</em>) – The input gpu array, with size = Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gy: The output gpu array, with size = (M,)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype = numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._forward_legacy">
<code class="sig-name descname">_forward_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._forward_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype = numpy.complex64</em>) – The input gpu array, with size = Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gy: The output gpu array, with size = (M,)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype = numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._init__cpu">
<code class="sig-name descname">_init__cpu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._init__cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python NoneType</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NUFFT: the pynufft_hsa.NUFFT instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NUFFT: the pynufft_hsa.NUFFT class</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._init__device">
<code class="sig-name descname">_init__device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">device_indx</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._init__device" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>API</strong> (<em>string</em>) – The API for the heterogeneous system. API=’cuda’
or API=’ocl’</p></li>
<li><p><strong>platform_number</strong> (<em>integer</em>) – The number of the platform found by the API.</p></li>
<li><p><strong>device_number</strong> (<em>integer</em>) – The number of the device found on the platform.</p></li>
<li><p><strong>verbosity</strong> (<em>integer</em>) – Defines the verbosity level, default value is 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_hsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_device</span><span class="p">(</span><span class="n">API</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">platform_number</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="go">                                 device_number=0, verbosity=0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2xx_cpu">
<code class="sig-name descname">_k2xx_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2xx_cpu" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the inverse FFT and image cropping (which is the reverse of</dt><dd><p>_xx2k() method)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2xx_device">
<code class="sig-name descname">_k2xx_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2xx_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: the inverse FFT and image cropping (which is the reverse of
_xx2k() method)</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2xx_one2one_cpu">
<code class="sig-name descname">_k2xx_one2one_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2xx_one2one_cpu" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the inverse FFT and image cropping</dt><dd><p>(which is the reverse of _xx2k() method)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2y2k_cpu">
<code class="sig-name descname">_k2y2k_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2y2k_cpu" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: the integrated interpolation-gridding by the Sparse</dt><dd><p>Matrix-Vector Multiplication</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2y_cpu">
<code class="sig-name descname">_k2y_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2y_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: interpolation by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2y_device">
<code class="sig-name descname">_k2y_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2y_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: interpolation by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._k2y_legacy">
<code class="sig-name descname">_k2y_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._k2y_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: interpolation by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._offload_device">
<code class="sig-name descname">_offload_device</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._offload_device" title="Permalink to this definition">¶</a></dt>
<dd><p>self.offload():</p>
<p>Off-load NUFFT to the opencl or cuda device(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>API</strong> (<em>string</em>) – define the device type, which can be ‘cuda’ or ‘ocl’</p></li>
<li><p><strong>platform_number</strong> (<em>int</em>) – define which platform to be used.
The default platform_number = 0.</p></li>
<li><p><strong>device_number</strong> (<em>int</em>) – define which device to be used.
The default device_number = 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self: instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._offload_legacy">
<code class="sig-name descname">_offload_legacy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._offload_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>self.offload():</p>
<p>Off-load NUFFT to the opencl or cuda device(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>API</strong> (<em>string</em>) – define the device type, which can be ‘cuda’ or ‘ocl’</p></li>
<li><p><strong>platform_number</strong> (<em>int</em>) – define which platform to be used. The default platform_number = 0.</p></li>
<li><p><strong>device_number</strong> (<em>int</em>) – define which device to be used. The default device_number = 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self: instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._plan_cpu">
<code class="sig-name descname">_plan_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">ft_axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._plan_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Plan the NUFFT_cpu object with the geometry provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size = M * ndims</em>) – The M off-grid locates in the frequency domain,
which is normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the equispaced image.
Example: Nd=(256,256) for a 2D image;</p>
<blockquote>
<div><p>Nd = (128,128,128) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the oversampled frequency grid.
Example: Kd=(512,512) for 2D image;</p>
<blockquote>
<div><p>Kd = (256,256,256) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The interpolator size.
Example: Jd=(6,6) for 2D image;</p>
<blockquote>
<div><p>Jd = (6,6,6) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>ft_axes</strong> (<em>None</em><em>, or </em><em>tuple with optional integer elements.</em>) – (Optional) The axes for Fourier transform.
The default is all axes if ‘None’ is given.</p></li>
<li><p><strong>batch</strong> – (Optional) Batch mode.
If the batch is provided, the last appended axis is the number
of identical NUFFT to be transformed.
The default is ‘None’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Nd</strong> – initial value: Nd</p></li>
<li><p><strong>Kd</strong> – initial value: Kd</p></li>
<li><p><strong>Jd</strong> – initial value: Jd</p></li>
<li><p><strong>ft_axes</strong> – initial value: None</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._plan_device">
<code class="sig-name descname">_plan_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">ft_axes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radix</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._plan_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Design the multi-coil or single-coil memory reduced interpolator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size =</em><em> (</em><em>M</em><em>, </em><em>ndims</em><em>)</em>) – The M off-grid locations in the frequency domain.
Normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of equispaced image.
Example: Nd=(256, 256) for a 2D image;</p>
<blockquote>
<div><p>Nd = (128, 128, 128) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The matrix size of the oversampled frequency grid.
Example: Kd=(512,512) for 2D image;
Kd = (256,256,256) for a 3D image</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The interpolator size.
Example: Jd=(6,6) for 2D image;
Jd = (6,6,6) for a 3D image</p></li>
<li><p><strong>ft_axes</strong> (<em>tuple</em><em>, </em><em>selected axes to be transformed.</em>) – The dimensions to be transformed by FFT.
Example: ft_axes = (0, 1) for 2D,
ft_axes = (0, 1, 2) for 3D;
ft_axes = None for all dimensions.</p></li>
<li><p><strong>radix</strong> – expert mode.
If provided, the shape is Nd.
The last axis is the number of parallel coils.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT_hsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT_device</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._plan_legacy">
<code class="sig-name descname">_plan_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">ft_axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._plan_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Design the min-max interpolator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size = M * ndims</em>) – The M off-grid locations in the frequency domain. Normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The matrix size of equispaced image. Example: Nd=(256,256) for a 2D image; Nd = (128,128,128) for a 3D image</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The matrix size of the oversampled frequency grid. Example: Kd=(512,512) for 2D image; Kd = (256,256,256) for a 3D image</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – The interpolator size. Example: Jd=(6,6) for 2D image; Jd = (6,6,6) for a 3D image</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pynufft</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">pynufft</span><span class="o">.</span><span class="n">NUFFT_cpu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._precompute_sp_cpu">
<code class="sig-name descname">_precompute_sp_cpu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._precompute_sp_cpu" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Private: Precompute adjoint (gridding) and Toepitz interpolation</dt><dd><p>matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python Nonetype</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self: instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._selfadjoint_cpu">
<code class="sig-name descname">_selfadjoint_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._selfadjoint_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT on CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._selfadjoint_device">
<code class="sig-name descname">_selfadjoint_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._selfadjoint_device" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype =numpy.complex64</em>) – The input gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._selfadjoint_legacy">
<code class="sig-name descname">_selfadjoint_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._selfadjoint_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT on the heterogeneous device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gx</strong> (<em>reikna gpu array with dtype =numpy.complex64</em>) – The input gpu array, with size=Nd</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gx: The output gpu array, with size=Nd</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>reikna gpu array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._solve_cpu">
<code class="sig-name descname">_solve_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._solve_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve NUFFT_cpu.
:param y: data, numpy.complex64. The shape = (M,) or (M, batch)
:param solver: ‘cg’, ‘L1TVOLS’, ‘lsmr’, ‘lsqr’, ‘dc’, ‘bicg’,</p>
<blockquote>
<div><p>‘bicgstab’, ‘cg’, ‘gmres’,’lgmres’</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array with size.
The shape = Nd (‘L1TVOLS’) or  Nd 
(‘lsmr’, ‘lsqr’, ‘dc’,’bicg’,’bicgstab’,’cg’, ‘gmres’,’lgmres’)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._solve_device">
<code class="sig-name descname">_solve_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gy</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._solve_device" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver of NUFFT_hsa</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gy</strong> (<em>reikna array</em><em>, </em><em>dtype = numpy.complex64</em>) – data, reikna array, (M,) size</p></li>
<li><p><strong>solver</strong> (<em>string</em>) – could be ‘cg’, ‘L1TVOLS’, ‘L1TVLAD’</p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reikna array with size Nd</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._solve_legacy">
<code class="sig-name descname">_solve_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gy</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._solve_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver of NUFFT_hsa</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gy</strong> (<em>reikna array</em><em>, </em><em>dtype = numpy.complex64</em>) – data, reikna array, (M,) size</p></li>
<li><p><strong>solver</strong> (<em>string</em>) – could be ‘cg’, ‘L1TVOLS’, ‘L1TVLAD’</p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reikna array with size Nd</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._vec2k_cpu">
<code class="sig-name descname">_vec2k_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k_vec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._vec2k_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorting the vector to k-spectrum Kd array</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._vec2y_cpu">
<code class="sig-name descname">_vec2y_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k_vec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._vec2y_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>gridding:</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._x2xx_cpu">
<code class="sig-name descname">_x2xx_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._x2xx_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: Scaling on CPU
Inplace multiplication of self.x_Nd by the scaling factor self.sn.</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._xx2k_cpu">
<code class="sig-name descname">_xx2k_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._xx2k_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on CPU</p>
<p>Firstly, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._xx2k_device">
<code class="sig-name descname">_xx2k_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._xx2k_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on the heterogeneous device</p>
<p>First, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._xx2k_one2one_cpu">
<code class="sig-name descname">_xx2k_one2one_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._xx2k_one2one_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: oversampled FFT on CPU</p>
<p>First, zeroing the self.k_Kd array
Second, copy self.x_Nd array to self.k_Kd array by cSelect
Third, inplace FFT</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._xx2x_cpu">
<code class="sig-name descname">_xx2x_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._xx2x_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: rescaling, which is identical to the  _x2xx() method</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._y2k_cpu">
<code class="sig-name descname">_y2k_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._y2k_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: gridding by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._y2k_device">
<code class="sig-name descname">_y2k_device</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._y2k_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: gridding by the Sparse Matrix-Vector Multiplication
Atomic_twosum together provide better accuracy than generic atomic_add. 
See: ocl_add and cuda_add code-strings in atomic_add(), inside the re_subroutine.py.</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._y2k_legacy">
<code class="sig-name descname">_y2k_legacy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._y2k_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: gridding by the Sparse Matrix-Vector Multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT._y2vec_cpu">
<code class="sig-name descname">_y2vec_cpu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT._y2vec_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>regridding non-uniform data (unsorted vector)</p>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint NUFFT (host code)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> – The input numpy array, with the size of (M,)</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array,
with the size of Nd or Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward NUFFT (host code)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with the size of Nd</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>y: The output numpy array, with the size of (M,)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with the dtype of numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.plan">
<code class="sig-name descname">plan</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Plan the NUFFT object with the geometry provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float array</em><em>, </em><em>matrix size = M * ndims</em>) – The M off-grid locates in the frequency domain,
which is normalized between [-pi, pi]</p></li>
<li><p><strong>Nd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the equispaced image.
Example: Nd=(256,256) for a 2D image;</p>
<blockquote>
<div><p>Nd = (128,128,128) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Kd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The matrix size of the oversampled frequency grid.
Example: Kd=(512,512) for 2D image;</p>
<blockquote>
<div><p>Kd = (256,256,256) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>Jd</strong> (<em>tuple</em><em>, </em><em>ndims integer elements.</em>) – <p>The interpolator size.
Example: Jd=(6,6) for 2D image;</p>
<blockquote>
<div><p>Jd = (6,6,6) for a 3D image</p>
</div></blockquote>
</p></li>
<li><p><strong>ft_axes</strong> (<em>None</em><em>, or </em><em>tuple with optional integer elements.</em>) – (Optional) The axes for Fourier transform.
The default is all axes if ‘None’ is given.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, float</p>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Nd</strong> – initial value: Nd</p></li>
<li><p><strong>Kd</strong> – initial value: Kd</p></li>
<li><p><strong>Jd</strong> – initial value: Jd</p></li>
<li><p><strong>ft_axes</strong> – initial value: None</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUFFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUFFT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span><span class="o">.</span><span class="n">plan</span><span class="p">(</span><span class="n">om</span><span class="p">,</span> <span class="n">Nd</span><span class="p">,</span> <span class="n">Kd</span><span class="p">,</span> <span class="n">Jd</span><span class="p">,</span> <span class="n">ft_axes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.selfadjoint">
<code class="sig-name descname">selfadjoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.selfadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>selfadjoint NUFFT (host code)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – The input numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x: The output numpy array, with size=Nd</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array with dtype =numpy.complex64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynufft.nufft.__init__.NUFFT.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.NUFFT.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve NUFFT (host code)
:param y: data, numpy.complex64. The shape = (M,) 
:param solver: ‘cg’, ‘L1TVOLS’, ‘lsmr’, ‘lsqr’, ‘dc’, ‘bicg’,</p>
<blockquote>
<div><p>‘bicgstab’, ‘cg’, ‘gmres’,’lgmres’</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxiter</strong> (<em>int</em>) – the number of iterations</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array with size Nd.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynufft.nufft.__init__.push_cuda_context">
<code class="sig-prename descclassname">pynufft.nufft.__init__.</code><code class="sig-name descname">push_cuda_context</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hsa_method</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.nufft.__init__.push_cuda_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator: Push cude context to the top of the stack for current use
Add &#64;push_cuda_context before the methods of NUFFT_device()</p>
</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.solve_cpu"></span><div class="section" id="cpu-solvers">
<h3>CPU solvers<a class="headerlink" href="#cpu-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="pynufft.linalg.solve_cpu.L1TVOLS">
<code class="sig-prename descclassname">pynufft.linalg.solve_cpu.</code><code class="sig-name descname">L1TVOLS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">maxiter</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.L1TVOLS" title="Permalink to this definition">¶</a></dt>
<dd><p>L1-total variation regularized ordinary least square</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_cpu._create_kspace_sampling_density">
<code class="sig-prename descclassname">pynufft.linalg.solve_cpu.</code><code class="sig-name descname">_create_kspace_sampling_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu._create_kspace_sampling_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute k-space sampling density</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_cpu._pipe_density">
<code class="sig-prename descclassname">pynufft.linalg.solve_cpu.</code><code class="sig-name descname">_pipe_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">maxiter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu._pipe_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the density function by iterative solution
Generate pHp matrix</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_cpu.cDiff">
<code class="sig-prename descclassname">pynufft.linalg.solve_cpu.</code><code class="sig-name descname">cDiff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">d_indx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute image gradient, which needs the results of indxmap_diff(Nd)
:param x: The image array
:param d_indx: The index of the shifted image
:type x: numpy.float array, matrix size = Nd
:type d_indx: int32
:returns: x_diff: Image gradient determined by d_indx
:rtype: x_diff: numpy.complex64</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_cpu.solve">
<code class="sig-prename descclassname">pynufft.linalg.solve_cpu.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_cpu.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve NUFFT.
The current version supports solvers = ‘cg’ or ‘L1TVOLS’ or ‘L1TVLAD’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nufft</strong> – NUFFT_cpu object</p></li>
<li><p><strong>y</strong> – (M,) array, non-uniform data</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x: image</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.solve_hsa"></span><div class="section" id="hsa-solvers">
<h3>HSA solvers<a class="headerlink" href="#hsa-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="pynufft.linalg.solve_hsa.L1TVLAD">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">L1TVLAD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">gy</span></em>, <em class="sig-param"><span class="n">maxiter</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.L1TVLAD" title="Permalink to this definition">¶</a></dt>
<dd><p>(testing) L1-total variation regularized least absolute deviation</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_hsa.L1TVOLS">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">L1TVOLS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">gy</span></em>, <em class="sig-param"><span class="n">maxiter</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.L1TVOLS" title="Permalink to this definition">¶</a></dt>
<dd><p>L1-total variation regularized ordinary least square</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_hsa._create_kspace_sampling_density">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">_create_kspace_sampling_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa._create_kspace_sampling_density" title="Permalink to this definition">¶</a></dt>
<dd><p>(stable) Compute k-space sampling density from the nufft object</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_hsa._pipe_density">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">_pipe_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">maxiter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa._pipe_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Private: create the density function in the data space by a iterative solution
Pipe et al. 1999</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_hsa.cDiff">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">cDiff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">d_indx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>(stable) Compute image gradient
Work with indxmap_diff(Nd).
…</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.linalg.solve_hsa.solve">
<code class="sig-prename descclassname">pynufft.linalg.solve_hsa.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em>, <em class="sig-param"><span class="n">gy</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.solve_hsa.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The solve function of NUFFT_hsa.
The current version supports solvers = ‘cg’ or ‘L1TVOLS’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nufft</strong> – NUFFT_hsa object</p></li>
<li><p><strong>y</strong> (<em>numpy.complex64 reikna array</em>) – (M,) array, non-uniform data. If batch is provided, ‘cg’ and ‘L1TVOLS’ returns different image shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x: Nd image. L1TVOLS always returns Nd. ‘cg’ returns Nd.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>x: reikna array, complex64.</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pynufft.linalg.nudft_cpu"></span><div class="section" id="nudft-class">
<h3>NUDFT class<a class="headerlink" href="#nudft-class" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="pynufft.linalg.nudft_cpu.NUDFT">
<em class="property">class </em><code class="sig-prename descclassname">pynufft.linalg.nudft_cpu.</code><code class="sig-name descname">NUDFT</code><a class="headerlink" href="#pynufft.linalg.nudft_cpu.NUDFT" title="Permalink to this definition">¶</a></dt>
<dd><p>The non-uniform DFT operator</p>
<dl class="py method">
<dt id="pynufft.linalg.nudft_cpu.NUDFT.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.linalg.nudft_cpu.NUDFT.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> (<em>Python NoneType</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NUFFT: the pynufft.NUDFT instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NUFFT: the pynufft.NUFFT class</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">NUDFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NufftObj</span> <span class="o">=</span> <span class="n">NUDFT</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.linalg.nudft_cpu.NUDFT.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pynufft.linalg.nudft_cpu.NUDFT.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.linalg.nudft_cpu.NUDFT.debug">
<code class="sig-name descname">debug</code><a class="headerlink" href="#pynufft.linalg.nudft_cpu.NUDFT.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>initial value: 0</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-pynufft.src._helper.helper"></span><div class="section" id="helper-functions">
<h3>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="pynufft.src._helper.helper.ELL">
<em class="property">class </em><code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">ELL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">elldata</span></em>, <em class="sig-param"><span class="n">ellcol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.ELL" title="Permalink to this definition">¶</a></dt>
<dd><p>ELL is slow on a single core CPU</p>
<dl class="py method">
<dt id="pynufft.src._helper.helper.ELL.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">elldata</span></em>, <em class="sig-param"><span class="n">ellcol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.ELL.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.src._helper.helper.ELL.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.ELL.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.OMEGA_k">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">OMEGA_k</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">omd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">dimid</span></em>, <em class="sig-param"><span class="n">dd</span></em>, <em class="sig-param"><span class="n">ft_flag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.OMEGA_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the index of k-space k_indx</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.QR_process">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">QR_process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">sn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.QR_process" title="Permalink to this definition">¶</a></dt>
<dd><p>1D QR method for generating min-max interpolator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float32</em>) – non-Cartesian coordinate. shape = (M, dims)</p></li>
<li><p><strong>N</strong> (<em>int</em>) – length</p></li>
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled grid</p></li>
<li><p><strong>sn</strong> (<em>numpy.float32 shape =</em><em> (</em><em>N</em><em>,</em><em>)</em>) – scaling factor as a length-N vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="pynufft.src._helper.helper.Tensor_sn">
<em class="property">class </em><code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">Tensor_sn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snd</span></em>, <em class="sig-param"><span class="n">radix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented:</p>
<dl class="py method">
<dt id="pynufft.src._helper.helper.Tensor_sn.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snd</span></em>, <em class="sig-param"><span class="n">radix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.src._helper.helper.Tensor_sn.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.Tensor_sn.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.block_outer_prod">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">block_outer_prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply x1 (J1 x M) and x2 (J2xM) and extend the dimensions to 3D (J1xJ2xM)</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.block_outer_sum">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">block_outer_sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the new index after adding a new axis</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.block_outer_sum0">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">block_outer_sum0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.block_outer_sum0" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply x1 (J1 x M) and x2 (J2xM) and extend the dimensions to 3D (J1xJ2xM)</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.cat_snd">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">cat_snd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.cat_snd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>snd</strong> (<em>tuple</em>) – tuple of input 1D vectors</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tensor_sn: vector of concatenated scaling factor, shape = (numpy.sum(Nd), )</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tensor_sn: numpy.float32</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.create_laplacian_kernel">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">create_laplacian_kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nufft</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.create_laplacian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the multi-dimensional laplacian kernel in k-space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nufft</strong> – the NUFFT object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>uker: the multi-dimensional laplacian kernel in k-space (no fft shift used)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.create_partialELL">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">create_partialELL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ud</span></em>, <em class="sig-param"><span class="n">kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">M</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.create_partialELL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ud</strong> (<em>tuple of numpy.complex64 arrays</em>) – tuple of all 1D interpolators</p></li>
<li><p><strong>kd</strong> (<em>tuple of numpy.int32 arrays</em>) – tuple of all 1D indices</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int32</em>) – tuple of interpolation sizes</p></li>
<li><p><strong>M</strong> (<em>int</em>) – number of samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>partialELL:</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>partialELL: pELL instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.crop_slice_ind">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">crop_slice_ind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Nd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.crop_slice_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated in v.0.3.4)
Return the “slice” of Nd size to index multi-dimensional array.  “Slice” functions as the index of the array.
This function is superseded by preindex_copy(), which avoid run-time indexing.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.device_list">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">device_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.device_list" title="Permalink to this definition">¶</a></dt>
<dd><p>device_list() returns available devices for acceleration as a tuple.
If no device is available, it returns an empty tuple.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.diagnose">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">diagnose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbosity</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.diagnose" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagnosis function
Find available devices when NUFFT.offload() fails.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.get_sn">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">get_sn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.get_sn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 1D scaling factor for the given J, K, N</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled grid</p></li>
<li><p><strong>N</strong> (<em>int</em>) – length</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sn:  scaling factor as a length-N vector</p>
</dd>
<dt class="field-odd">Rtype sn</dt>
<dd class="field-odd"><p>numpy.float32 shape = (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.indxmap_diff">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">indxmap_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Nd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.indxmap_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Preindixing for rapid image gradient.
Diff(x) = x.flat[d_indx[0]] - x.flat
Diff_t(x) =  x.flat[dt_indx[0]] - x.flat</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Nd</strong> (<em>tuple with integers</em>) – the dimension of the image</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>d_indx: image gradient</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dt_indx:  the transpose of the image gradient</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>d_indx: lists with numpy ndarray</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dt_indx: lists with numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.kaiser_bessel_ft">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">kaiser_bessel_ft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">kb_m</span></em>, <em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.kaiser_bessel_ft" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolation weight for given J/alpha/kb-m</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.kronecker_scale">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">kronecker_scale</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.kronecker_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kronecker product of the scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snd</strong> (<em>tuple of 1D numpy.array</em>) – Tuple of 1D scaling factors</p></li>
<li><p><strong>dd</strong> – Number of dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sn: The multi-dimensional Kronecker of the scaling factors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nd array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.nufft_T">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">nufft_T</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_T" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation (29) and (26) in Fessler and Sutton 2003.
Create the overlapping matrix CSSC (diagonal dominant matrix)
of J points, then find the pseudo-inverse of CSSC</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.nufft_alpha_kb_fit">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">nufft_alpha_kb_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_alpha_kb_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find parameters alpha and beta for scaling factor st[‘sn’]
The alpha is hardwired as [1,0,0…] when J = 1 (uniform scaling factor)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – size of image</p></li>
<li><p><strong>J</strong> (<em>int</em>) – size of interpolator</p></li>
<li><p><strong>K</strong> (<em>int</em>) – size of oversampled k-space</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>alphas:</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>beta:</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>alphas: list of float</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>beta:</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.nufft_offset">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">nufft_offset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For every om point (outside regular grids), find the nearest
central grid (from Kd dimension)</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.nufft_r">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">nufft_r</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation (30) of Fessler &amp; Sutton’s paper</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.nufft_scale1">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">nufft_scale1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">K</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">Nmid</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.nufft_scale1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate image space scaling factor</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.outer_sum">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">outer_sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xx</span></em>, <em class="sig-param"><span class="n">yy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.outer_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Superseded by numpy.add.outer() function</p>
</dd></dl>

<dl class="py class">
<dt id="pynufft.src._helper.helper.pELL">
<em class="property">class </em><code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">pELL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">curr_sumJd</span></em>, <em class="sig-param"><span class="n">meshindex</span></em>, <em class="sig-param"><span class="n">kindx</span></em>, <em class="sig-param"><span class="n">udata</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.pELL" title="Permalink to this definition">¶</a></dt>
<dd><p>class pELL: partial ELL format</p>
<dl class="py method">
<dt id="pynufft.src._helper.helper.pELL.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">curr_sumJd</span></em>, <em class="sig-param"><span class="n">meshindex</span></em>, <em class="sig-param"><span class="n">kindx</span></em>, <em class="sig-param"><span class="n">udata</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.pELL.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>int</em>) – Number of samples</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – Interpolator size</p></li>
<li><p><strong>curr_sumJd</strong> (<em>tuple of int</em>) – Summation of Jd[0:d-1], for fast shift computing</p></li>
<li><p><strong>meshindex</strong> (<em>numpy.uint32</em><em>, </em><em>shape =</em><em>  (</em><em>numpy.prod</em><em>(</em><em>Jd</em><em>)</em><em>,  </em><em>dd</em><em>)</em>) – The tensor indices to all interpolation points</p></li>
<li><p><strong>kindx</strong> (<em>numpy.uint32</em><em>, </em><em>shape =</em><em> (</em><em>M</em><em>, </em><em>numpy.sum</em><em>(</em><em>Jd</em><em>)</em><em>)</em>) – Premixed k-indices to be combined</p></li>
<li><p><strong>udata</strong> (<em>numpy.complex64</em><em>, </em><em>shape =</em><em> (</em><em>M</em><em>, </em><em>numpy.sum</em><em>(</em><em>Jd</em><em>)</em><em>)</em>) – Premixed interpolation data values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pELL: partial ELLpack class with the given values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pELL: partial ELLpack class</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pynufft.src._helper.helper.pELL.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pynufft.src._helper.helper.pELL.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.plan">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">plan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">ft_axes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">format</span><span class="o">=</span><span class="default_value">'CSR'</span></em>, <em class="sig-param"><span class="n">radix</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Plan for the NUFFT object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>om</strong> (<em>numpy.float</em>) – Coordinate</p></li>
<li><p><strong>Nd</strong> (<em>tuple of int</em>) – Image shape</p></li>
<li><p><strong>Kd</strong> (<em>tuple of int</em>) – Oversampled grid shape</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – Interpolator size</p></li>
<li><p><strong>ft_axes</strong> (<em>tuple of int</em>) – Axes where FFT takes place</p></li>
<li><p><strong>format</strong> (<em>string</em><em>, </em><em>'CSR'</em><em> or </em><em>'pELL'</em>) – Output format of the interpolator.
‘CSR’: the precomputed Compressed Sparse Row (CSR) matrix.
‘pELL’: partial ELLPACK which precomputes the concatenated 1D interpolators.</p></li>
</ul>
</dd>
<dt class="field-even">Return st</dt>
<dd class="field-even"><p>dictionary for NUFFT</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.plan1">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">plan1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">om</span></em>, <em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">ft_axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.plan1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the coil sensitivity aware interpolator</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.preindex_copy">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">preindex_copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Nd</span></em>, <em class="sig-param"><span class="n">Kd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.preindex_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Building the array index for copying two arrays of sizes Nd and Kd.
Only the front parts of the input/output arrays are copied.
The oversize  parts of the input array are truncated (if Nd &gt; Kd), 
and the smaller size are zero-padded (if Nd &lt; Kd)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Nd</strong> (<em>tuple with integer elements</em>) – tuple, the dimensions of array1</p></li>
<li><p><strong>Kd</strong> (<em>tuple with integer elements</em>) – tuple, the dimensions of array2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inlist: the index of the input array</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>outlist: the index of the output array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nelem: the length of the inlist and outlist (equal length)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>inlist: list with integer elements</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>outlist: list with integer elements</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nelem: int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.rdx_kron">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">rdx_kron</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ud</span></em>, <em class="sig-param"><span class="n">kd</span></em>, <em class="sig-param"><span class="n">Jd</span></em>, <em class="sig-param"><span class="n">radix</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.rdx_kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Radix-n Kronecker product of multi-dimensional array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ud</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.complex64 arrays</em>) – 1D interpolators</p></li>
<li><p><strong>kd</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.uint arrays</em>) – 1D indices to interpolators</p></li>
<li><p><strong>Jd</strong> (<em>tuple of int</em>) – 1D interpolator sizes</p></li>
<li><p><strong>radix</strong> (<em>int</em>) – radix of Kronecker product</p></li>
<li><p><strong>kk</strong> (<em>tuple of</em><em> (</em><em>M</em><em>, </em><em>Jd</em><em>[</em><em>d</em><em>]</em><em>) </em><em>numpy.uint arrays</em>) – 1D indices to interpolators</p></li>
<li><p><strong>JJ</strong> (<em>tuple of int</em>) – 1D interpolator sizes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>uu: 1D interpolators</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src._helper.helper.strides_divide_itemsize">
<code class="sig-prename descclassname">pynufft.src._helper.helper.</code><code class="sig-name descname">strides_divide_itemsize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Nd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src._helper.helper.strides_divide_itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>strides_divide_itemsize function computes the step_size (strides/itemsize) along different axes, and its inverse as float32.
For fast GPU computing, preindexing allows for fast Hadamard product and copy.
However preindexing costs some memory.
strides_divide_itemsize aims to replace preindexing by run-time calculation of the index, given the invNd_elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Nd</strong> (<em>tuple of int</em>) – Input shape</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Nd_elements: strides/itemsize of the Nd.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>invNd_elements: (float32)(1/Nd_elements). Division on GPU is slow but multiply is fast. Thus we can precompute the inverse and then multiply the inverse on GPU.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Nd_elements: tuple of int</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>invNd_elements: tuple of float32</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pynufft.NUFFT_hsa</span></code></p>
</div>
</dd></dl>

</div>
<span class="target" id="module-pynufft.src.re_subroutine"></span><div class="section" id="metaprogramming-subroutines-using-reikna-pyopencl-pycuda">
<h3>Metaprogramming subroutines (using reikna, pyopencl, pycuda)<a class="headerlink" href="#metaprogramming-subroutines-using-reikna-pyopencl-pycuda" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="pynufft.src.re_subroutine.atomic_add">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">atomic_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">API</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.atomic_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic_add for the given API. 
Overcome the missing atomic_add_float for OpenCL-1.2. 
Note: will be checked if OpenCL 2.0 provided by all GPU vendors.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cAddScalar">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cAddScalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAddScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cAddScalar.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cAddVec">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cAddVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAddVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cAddVec.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cAnisoShrink">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cAnisoShrink</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cAnisoShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cAnisoShrink</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cCopy">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cCopy</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cDiff">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cDiff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cDiff.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cHadamard">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cHadamard</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cHadamard" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hadamard operations related kernel sources.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cHypot">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cHypot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cHypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel code for hypot, which computes the sqrt(x*x + y*y) without intermediate overflow.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyConjVec">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyConjVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyConjVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyConjVec.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyConjVecInplace">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyConjVecInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyConjVecInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyConjVecInplace</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyRealInplace">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyRealInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyRealInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyRealInplace.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyScalar">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyScalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cMultiplyScalar.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyVec">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyVec</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cMultiplyVecInplace">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cMultiplyVecInplace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cMultiplyVecInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cMultiplyVecInplace.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cSelect">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cSelect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cSelect.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cSpmv">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cSpmv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSpmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel sources for cSpmv related operations,
providing cCSR_spmv_vector and cpELL_spmv_mCoil.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cSpmvh">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cSpmvh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSpmvh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cSpmvh related kernel source. 
Only pELL_spmvh_mCoil is provided for Spmvh.
NUFFT_hsa_legacy reuses the cCSR_spmv() function, which doubles the storage.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cSqrt">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cSqrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cSqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source of cSqrt.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cTensorCopy">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cTensorCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cTensorCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cTensorCopy.</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.cTensorMultiply">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">cTensorMultiply</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.cTensorMultiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the kernel source for cTensorMultiply</p>
</dd></dl>

<dl class="py function">
<dt id="pynufft.src.re_subroutine.create_kernel_sets">
<code class="sig-prename descclassname">pynufft.src.re_subroutine.</code><code class="sig-name descname">create_kernel_sets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">API</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynufft.src.re_subroutine.create_kernel_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the kernel from the kernel sets.
Note that in some tests (Benoit’s and my tests) CUDA shows some degraded accuracy. 
This loss of accuracy was due to undefined shared memory behavior, which I don’t fully understand.
This has been fixed in 2019.2.0 as the operations are moved to global memory.</p>
</dd></dl>

</div>
</div>
<span id="document-installation/init"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="system-requirements">
<h3>System requirements<a class="headerlink" href="#system-requirements" title="Permalink to this headline">¶</a></h3>
<p><strong>CPU</strong></p>
<p>Each PyNUFFT instance is designed to be executed on a single node.
PyNUFFT is not designed for distributed computing on multiple nodes,
but the user may install PyNUFFT on multiple nodes and control them through the network.</p>
<p>Multple NUFFT_cpu instances on a single node provided that the total memory is sufficient to keep all instances.</p>
<p>We recommend one or more modern x86_64 processors on a single node. Successful stories include Intel® Core™ i7-6700HQ Processor,
Intel® Xeon® W-2125, Intel® Core™ i9-7900X.</p>
<p><strong>Memory</strong></p>
<p>A general instruction is that the memory should be sufficient for computing a single NUFFT object, which is dependent on the type of problem.</p>
<p>A single 2D problem of 256 × 256 matrix can be computed on a system with 8GB memory.</p>
<p>For 3D NUFFT, it is not uncommon for a single NUFFT_cpu object to consume more than 200GB memory.</p>
<p><strong>GPU</strong></p>
<p>Each PyNUFFT instance is initiated on a single GPU. An instance cannot be distributed across multiple GPUs.
(PyNUFFT does not use cuFFT.)</p>
<p>However, multiple NUFFT_hsa instances may be initiated both on a single GPU and on multiple GPUs,
but the performance may be impacted (limited by the memory, PCI-E bus or GPU cores).</p>
<p>To use GPU, a recent NVIDIA’s GPU (after Maxwell, Pascal) with the recent drivers should be working properly.</p>
<p>The newest nvidia-driver versions of 415.18 or later is recommended.
Earlier versions may work but please be informed that Nvidia may discontinue support for outdated drivers.</p>
<p>A general rule is that the memory on the GPU has to be sufficient for computing the NUFFT problem.
Successful stories include NVIDIA Geforce GTX 965m/GTX 1070 maxQ/1060 6GB,
NVIDIA Titan V100 (Amazon Web Services),
NVIDIA Titan X Pascal,
and NVIDIA Quadro P6000.</p>
<p><strong>Operating System</strong></p>
<p>Ubunut 16.04 - 18.04 are recommended.</p>
<p>Windows 10 has been tested but it requires Microsoft Studio 2015 community. Please refer to the following special topic about the installation under Windows 10.</p>
</div>
<div class="section" id="software">
<h3>Software<a class="headerlink" href="#software" title="Permalink to this headline">¶</a></h3>
<p><strong>Python</strong></p>
<p>Users must be familiar with Python and its pip packaging system.
Python 2.7 and Python 3.6-3.7 are currently supported.</p>
<p>To run the NUFFT_cpu, the basic CPython, Numpy and Scipy packages must be available on the system.
IronPython is compatible with CPython so ipython might be useful.</p>
<p>PyNUFFT can be installed through the pip command.
Optionally, users can clone the github repository and build the package from the local folder.</p>
<p><strong>Compiler</strong></p>
<p>NUFFT_cpu class does not require a compiler.</p>
<p>However, NUFFT_hsa relies on the JIT (just-in-time) compilation mechanism of Reikna/PyCUDA/PyOpenCL.
The supporting compiler may be:</p>
<ul class="simple">
<li><p>gcc-7.3.0</p></li>
<li><p>Microsoft (R) Visual Studio 2015 community edition.</p></li>
</ul>
<p>(Please refer to the following section: special topic: Installation under Windows 10).</p>
<p>To accelerate the code on the graphic processing unit (GPU),
Reikna, PyCUDA, PyOpencl must be available. Please refer the following special topic: Installation of OpenCL.</p>
<p>CUDA programming skills are not strictly needed.
However, it may be helpful if users understand GPU programming.</p>
</div>
<div class="section" id="general-installation">
<h3>General Installation<a class="headerlink" href="#general-installation" title="Permalink to this headline">¶</a></h3>
<p>Continuum’s <a class="reference external" href="https://www.continuum.io/downloads">Anaconda</a> environment should provide all the above packages.</p>
<p><strong>Installation using pip</strong></p>
<p>Install pynufft by using the <a class="reference external" href="https://en.wikipedia.org/wiki/Pip_(package_manager)">pip</a> command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pip install pynufft
</pre></div>
</div>
<p><strong>Installation from Git Repository</strong></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Git">git</a> is a version control program, which allows you to clone the latest code base from the <a class="reference external" href="https://github.com/jyhmiinlin/pynufft">pynufft</a> repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/jyhmiinlin/pynufft
$ cd pynufft
$ python setup.py install --user
</pre></div>
</div>
<p><strong>Test whether the installation is successful</strong></p>
<p>In Python environment, import pynufft:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pynufft.tests</span> <span class="k">as</span> <span class="nn">tests</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tests</span><span class="o">.</span><span class="n">test_installation</span><span class="p">()</span>
</pre></div>
</div>
<p>If the required data and functions are available, you will see that all the required files exist:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">om1D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">om2D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">om3D</span><span class="o">.</span><span class="n">npz</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">phantom_3D_128_128_128</span><span class="o">.</span><span class="n">npz</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">phantom_256_256</span><span class="o">.</span><span class="n">npz</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">example_1D</span><span class="o">.</span><span class="n">py</span> <span class="n">exists</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">The</span> <span class="n">example_2D</span><span class="o">.</span><span class="n">py</span> <span class="n">exist</span><span class="o">.</span> <span class="kc">True</span>
<span class="n">reikna</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
<span class="n">pyopencl</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
<span class="n">pycuda</span>  <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Uninstall pynufft</strong></p>
<p>Simply use “pip uninstall” to remove pynufft:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pip uninstall pynufft
</pre></div>
</div>
</div>
<div class="section" id="special-topics">
<h3>Special topics<a class="headerlink" href="#special-topics" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-installation/Linux"></span><div class="section" id="installation-under-linux">
<h4>Installation under Linux<a class="headerlink" href="#installation-under-linux" title="Permalink to this headline">¶</a></h4>
<p><strong>Ubuntu 18.04</strong></p>
<p>A successful example is Ubuntu.</p>
<p>The working kernel shown in <cite>uname -a</cite> is 4.15.0-42-generic #45-Ubuntu.</p>
<p>The Nvidia related packages are: Nvidia-driver Version: 410.78       CUDA Version: 10.0</p>
<p><strong>Gentoo</strong></p>
<p>PyNUFF works with the package in Gentoo system:
dev-util/nvidia-cuda-sdk-9.2.88, dev-util/nvidia-cuda-toolkit-9.2.88,
dev-util/intel-ocl-sdk-4.4.0.117-r1, and x11-drivers/nvidia-drivers-430.40.</p>
</div>
<span id="document-installation/Windows"></span><div class="section" id="installation-under-windows-10">
<h4>Installation under Windows 10<a class="headerlink" href="#installation-under-windows-10" title="Permalink to this headline">¶</a></h4>
<p>PyNUFFT has been tested under the Windows 10 home edition.</p>
<p>The successful installation experience may be useful, but the actual process can be different due to the variety of software and hardware environments.</p>
<p>I used Nvidia-driver 417.35-notebook-win10-64bit-international-whql-rp, Anaconda3-2018.12-Windows-x86_64, PyCUDA 2018.1.1 from official pip, Microsoft Visual Studio 2015 Community, CUDA 9.2.148_win10 and cuda_9.2.148.1_windows (patch).</p>
<p>The following general guidance may work in your case but cannot be guaranteed.</p>
<p><strong>Pre-requisites</strong></p>
<ul class="simple">
<li><p>GPU, a clean Windows 10, Windows Visual Studio 2015 Community Version and CUDA 9.2.148</p></li>
</ul>
<p>This is the most complex step. Please refer to the official documentation of Nvidia:</p>
<p><cite>https://docs.nvidia.com/cuda/archive/9.2/cuda-installation-guide-microsoft-windows/index.html</cite></p>
<ul class="simple">
<li><p>First, install the Nvidia-driver 417.35-notebook-win10-64bit-international-whql-rp.</p></li>
<li><p>Second, install the Microsoft Visual Studio 2015 Community.</p></li>
<li><p>Third, install CUDA-9.2. Do not install an older driver.</p></li>
</ul>
<p>Now open command prompt <cite>cmd</cite>, type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nvcc</span> <span class="o">-</span><span class="n">V</span>
</pre></div>
</div>
<p>You may see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nvcc</span><span class="p">:</span> <span class="n">NVIDIA</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Cuda</span> <span class="n">compiler</span> <span class="n">driver</span>
<span class="n">Copyright</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="mi">2005</span><span class="o">-</span><span class="mi">2018</span> <span class="n">NVIDIA</span> <span class="n">Corporation</span>
<span class="n">Built</span> <span class="n">on</span> <span class="n">Tue_Jun_12_23</span><span class="p">:</span><span class="mi">09_12</span><span class="n">_Central_Daylight_time_2018</span>
<span class="n">Cuda</span> <span class="n">compilation</span> <span class="n">tool</span><span class="p">,</span> <span class="n">release</span> <span class="mf">9.2</span><span class="p">,</span> <span class="n">V9</span><span class="o">.</span><span class="mf">2.148</span>
</pre></div>
</div>
<p>which indicates that nvcc can be found in the system.</p>
<ul class="simple">
<li><p>Add the environmental variable path.</p></li>
</ul>
<p>If the system cannot find <cite>cl.exe</cite> when you type <cite>cl</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>C:\Users\User&gt;cl
`cl` is not recognized as an internal or external command,
operable program or batch file.
</pre></div>
</div>
<p>this error is due to the fact that Visual Studio has not been added to the system path, so the system cannot find cl.</p>
<p>Try to follow the webpage instruction at <cite>https://docs.microsoft.com/en-us/previous-versions/office/developer/sharepoint-2010/ee537574(v%3Doffice.14)</cite>.
Add “C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin” and “C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE”.</p>
<p>Once Visual Studio has been added to the system, open Windows cmd and it should find cl.exe</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\<span class="n">Users</span>\<span class="n">User</span><span class="o">&gt;</span><span class="n">cl</span>
<span class="n">Microsoft</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">C</span><span class="o">/</span><span class="n">C</span><span class="o">++</span> <span class="n">Optimizing</span> <span class="n">Compiler</span> <span class="n">Version</span> <span class="mf">19.0024215</span><span class="o">.</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x86</span>
<span class="n">Copyright</span> <span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">Microsoft</span> <span class="n">Corpooration</span><span class="o">.</span> <span class="n">All</span> <span class="n">rights</span> <span class="n">reserved</span><span class="o">.</span>

<span class="n">usage</span><span class="p">:</span> <span class="n">cl</span> <span class="p">[</span> <span class="n">option</span><span class="o">...</span> <span class="p">]</span> <span class="n">filename</span><span class="o">...</span> <span class="p">[</span> <span class="o">/</span><span class="n">link</span> <span class="n">linkoption</span><span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<p>without the earlier error message. If the error persists, the path must be modified again.</p>
<p><strong>Installation of Anaconda3</strong></p>
<ul class="simple">
<li><p>Now install Anaconda3. I downloaded Anaconda3-2018.12-Windows-x86_64. Once this is done you can follow the general installation procedure as described above.</p></li>
</ul>
<p><strong>Installation of Pytools, PyCUDA, and PyNUFFT</strong></p>
<ul>
<li><p>Open Anaconda3 command prompt, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pytools</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pycuda</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">reikna</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">pynufft</span>
</pre></div>
</div>
</li>
<li><p>Test PyNUFFT:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span>
<span class="kn">from</span> <span class="nn">pynufft</span> <span class="kn">import</span> <span class="n">tests</span>
<span class="n">tests</span><span class="o">.</span><span class="n">test_init</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</div>
<span id="document-installation/OpenCL"></span><div class="section" id="installation-of-opencl">
<h4>Installation of OpenCL<a class="headerlink" href="#installation-of-opencl" title="Permalink to this headline">¶</a></h4>
<p>OpenCL is one of the backends that PyNUFFT supports. Up to the present, PyNUFFT has used OpenCL-1.2. One missing feature of OpenCL-1.2 is <cite>atomicAdd</cite> for the array with floating point numbers.   PyNUFFT makes use of <cite>atomic_cmpxchg</cite> (compare and exchange) to implement the atomic_add_float subroutine, which can be seen in the <cite>pynufft.src.re_subroutine.atomic_add</cite>. This code has appeared in many resources, e.g. <cite>http://simpleopencl.blogspot.com/2013/05/atomic-operations-and-floats-in-opencl.html</cite> and <cite>https://github.com/clMathLibraries/clSPARSE/blob/master/src/library/kernels/csrmv_adaptive.cl</cite>.</p>
<p>Note that the OpenCL standard is still evolving and all of the OpenCL supports may change quickly. Old sdk may not work with the newest Intel chipsets. Please try different versions of the hardware and software.</p>
<p>The current compiler version is gcc version 7.3.0. Other compilers may be used on the target system but I haven’t tested any of them.</p>
<p><strong>Intel OpenCL</strong></p>
<p>Intel HD graphics after the Skylake generation usually support OpenCL as long as the suitable intel-sdk is installed.</p>
<p>One OpenCL example is a Gigabyte aero 14 Gentoo Linux on a machine with Intel Corporation HD Graphics 530 (rev 06). The dev-util/intel-ocl-sdk-4.4.0.117-r1 installed the <cite>intel_sdk_for_ocl_applications_2014_ubuntu_4.4.0.117_x64.tgz</cite> opencl package. The <cite>clinfo</cite> command shows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Platform</span> <span class="n">Name</span>                                   <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">OpenCL</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">devices</span>                                 <span class="mi">1</span>
<span class="n">Device</span> <span class="n">Name</span>                                     <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Core</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="n">i7</span><span class="o">-</span><span class="mi">6700</span><span class="n">HQ</span> <span class="n">CPU</span> <span class="o">@</span> <span class="mf">2.60</span><span class="n">GHz</span>
<span class="n">Device</span> <span class="n">Vendor</span>                                   <span class="n">Intel</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="n">Corporation</span>
<span class="n">Device</span> <span class="n">Vendor</span> <span class="n">ID</span>                                <span class="mh">0x8086</span>
<span class="n">Device</span> <span class="n">Version</span>                                  <span class="n">OpenCL</span> <span class="mf">1.2</span> <span class="p">(</span><span class="n">Build</span> <span class="mi">117</span><span class="p">)</span>
<span class="n">Driver</span> <span class="n">Version</span>                                  <span class="mf">1.2</span><span class="o">.</span><span class="mf">0.117</span>
<span class="n">Device</span> <span class="n">OpenCL</span> <span class="n">C</span> <span class="n">Version</span>                         <span class="n">OpenCL</span> <span class="n">C</span> <span class="mf">1.2</span>
<span class="n">Device</span> <span class="n">Type</span>                                     <span class="n">CPU</span>
<span class="n">Device</span> <span class="n">Profile</span>                                  <span class="n">FULL_PROFILE</span>
<span class="n">Device</span> <span class="n">Available</span>                                <span class="n">Yes</span>
<span class="n">Compiler</span> <span class="n">Available</span>                              <span class="n">Yes</span>
<span class="n">Linker</span> <span class="n">Available</span>                                <span class="n">Yes</span>
<span class="n">Max</span> <span class="n">compute</span> <span class="n">units</span>                               <span class="mi">8</span>
<span class="n">Max</span> <span class="n">clock</span> <span class="n">frequency</span>                             <span class="mi">2600</span><span class="n">MHz</span>
<span class="n">Device</span> <span class="n">Partition</span>                                <span class="p">(</span><span class="n">core</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">sub</span><span class="o">-</span><span class="n">devices</span>                     <span class="mi">8</span>
  <span class="n">Supported</span> <span class="n">partition</span> <span class="n">types</span>                     <span class="n">by</span> <span class="n">counts</span><span class="p">,</span> <span class="n">equally</span><span class="p">,</span> <span class="n">by</span> <span class="n">names</span> <span class="p">(</span><span class="n">Intel</span><span class="p">)</span>
  <span class="n">Supported</span> <span class="n">affinity</span> <span class="n">domains</span>                    <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">dimensions</span>                        <span class="mi">3</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">sizes</span>                             <span class="mi">8192</span><span class="n">x8192x8192</span>
<span class="n">Max</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span>                             <span class="mi">8192</span>
<span class="n">Preferred</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span> <span class="n">multiple</span>              <span class="mi">128</span>
<span class="n">Preferred</span> <span class="o">/</span> <span class="n">native</span> <span class="n">vector</span> <span class="n">sizes</span>
  <span class="n">char</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">32</span>
  <span class="n">short</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">16</span>
  <span class="nb">int</span>                                                  <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
  <span class="n">long</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>
  <span class="n">half</span>                                                 <span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span>        <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="nb">float</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
  <span class="n">double</span>                                               <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>        <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
<span class="n">Half</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>           <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Single</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">core</span><span class="p">)</span>
  <span class="n">Denormals</span>                                     <span class="n">Yes</span>
  <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">No</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">No</span>
  <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">No</span>
  <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
  <span class="n">Correctly</span><span class="o">-</span><span class="n">rounded</span> <span class="n">divide</span> <span class="ow">and</span> <span class="n">sqrt</span> <span class="n">operations</span>  <span class="n">No</span>
<span class="n">Double</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
  <span class="n">Denormals</span>                                     <span class="n">Yes</span>
  <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
  <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
  <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
  <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
<span class="n">Address</span> <span class="n">bits</span>                                    <span class="mi">64</span><span class="p">,</span> <span class="n">Little</span><span class="o">-</span><span class="n">Endian</span>
<span class="n">Global</span> <span class="n">memory</span> <span class="n">size</span>                              <span class="mi">33613447168</span> <span class="p">(</span><span class="mf">31.3</span><span class="n">GiB</span><span class="p">)</span>
<span class="n">Error</span> <span class="n">Correction</span> <span class="n">support</span>                        <span class="n">No</span>
<span class="n">Max</span> <span class="n">memory</span> <span class="n">allocation</span>                           <span class="mi">8403361792</span> <span class="p">(</span><span class="mf">7.826</span><span class="n">GiB</span><span class="p">)</span>
<span class="n">Unified</span> <span class="n">memory</span> <span class="k">for</span> <span class="n">Host</span> <span class="ow">and</span> <span class="n">Device</span>              <span class="n">Yes</span>
<span class="n">Minimum</span> <span class="n">alignment</span> <span class="k">for</span> <span class="nb">any</span> <span class="n">data</span> <span class="nb">type</span>             <span class="mi">128</span> <span class="nb">bytes</span>
<span class="n">Alignment</span> <span class="n">of</span> <span class="n">base</span> <span class="n">address</span>                       <span class="mi">1024</span> <span class="n">bits</span> <span class="p">(</span><span class="mi">128</span> <span class="nb">bytes</span><span class="p">)</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="nb">type</span>                        <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">size</span>                        <span class="mi">262144</span> <span class="p">(</span><span class="mi">256</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">line</span> <span class="n">size</span>                   <span class="mi">64</span> <span class="nb">bytes</span>
<span class="n">Image</span> <span class="n">support</span>                                   <span class="n">Yes</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">samplers</span> <span class="n">per</span> <span class="n">kernel</span>             <span class="mi">480</span>
  <span class="n">Max</span> <span class="n">size</span> <span class="k">for</span> <span class="mi">1</span><span class="n">D</span> <span class="n">images</span> <span class="kn">from</span> <span class="nn">buffer</span>            <span class="mi">525210112</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="mi">1</span><span class="n">D</span> <span class="ow">or</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">array</span> <span class="n">size</span>                 <span class="mi">2048</span> <span class="n">images</span>
  <span class="n">Max</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x16384</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="mi">3</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">2048</span><span class="n">x2048x2048</span> <span class="n">pixels</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">read</span> <span class="n">image</span> <span class="n">args</span>                 <span class="mi">480</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">write</span> <span class="n">image</span> <span class="n">args</span>                <span class="mi">480</span>
<span class="n">Local</span> <span class="n">memory</span> <span class="nb">type</span>                               <span class="n">Global</span>
<span class="n">Local</span> <span class="n">memory</span> <span class="n">size</span>                               <span class="mi">32768</span> <span class="p">(</span><span class="mi">32</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">args</span>                     <span class="mi">480</span>
<span class="n">Max</span> <span class="n">constant</span> <span class="n">buffer</span> <span class="n">size</span>                        <span class="mi">131072</span> <span class="p">(</span><span class="mi">128</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Max</span> <span class="n">size</span> <span class="n">of</span> <span class="n">kernel</span> <span class="n">argument</span>                     <span class="mi">3840</span> <span class="p">(</span><span class="mf">3.75</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Queue</span> <span class="n">properties</span>
  <span class="n">Out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">order</span> <span class="n">execution</span>                        <span class="n">Yes</span>
  <span class="n">Profiling</span>                                     <span class="n">Yes</span>
  <span class="n">Local</span> <span class="n">thread</span> <span class="n">execution</span> <span class="p">(</span><span class="n">Intel</span><span class="p">)</span>                <span class="n">Yes</span>
<span class="n">Prefer</span> <span class="n">user</span> <span class="n">sync</span> <span class="k">for</span> <span class="n">interop</span>                    <span class="n">No</span>
<span class="n">Profiling</span> <span class="n">timer</span> <span class="n">resolution</span>                      <span class="mi">1</span><span class="n">ns</span>
<span class="n">Execution</span> <span class="n">capabilities</span>
  <span class="n">Run</span> <span class="n">OpenCL</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
  <span class="n">Run</span> <span class="n">native</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
  <span class="n">SPIR</span> <span class="n">versions</span>                                 <span class="mf">1.2</span>
<span class="n">printf</span><span class="p">()</span> <span class="n">buffer</span> <span class="n">size</span>                            <span class="mi">1048576</span> <span class="p">(</span><span class="mi">1024</span><span class="n">KiB</span><span class="p">)</span>
<span class="n">Built</span><span class="o">-</span><span class="ow">in</span> <span class="n">kernels</span>                                <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
<span class="n">Device</span> <span class="n">Extensions</span>                               <span class="n">cl_khr_icd</span> <span class="n">cl_khr_global_int32_base_atomics</span> <span class="n">cl_khr_global_int32_extended_atomics</span> <span class="n">cl_khr_local_int32_base_atomics</span> <span class="n">cl_khr_local_int32_extended_atomics</span> <span class="n">cl_khr_byte_addressable_store</span> <span class="n">cl_khr_spir</span> <span class="n">cl_intel_exec_by_local_thread</span> <span class="n">cl_khr_depth_images</span> <span class="n">cl_khr_3d_image_writes</span> <span class="n">cl_khr_fp64</span>
</pre></div>
</div>
<p>Pure CPU system without Intel HD graphics may require the newest Intel SDK for OpenCL <cite>https://software.intel.com/en-us/intel-opencl</cite> and <cite>https://software.intel.com/en-us/articles/opencl-drivers</cite>. One pure CPU system with Intel i7 7900X can make use of Intel Studio 2019.</p>
<p><strong>Nvidia OpenCL</strong></p>
<p>NVIDIA also supports OpenCL 1.2. A successful installation made use of nvidia-driver 417.18 and CUDA-SDK-9.2.88 and gcc 7.3.0. clinfo shows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Platform</span> <span class="n">Name</span>                                   <span class="n">NVIDIA</span> <span class="n">CUDA</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">devices</span>                                 <span class="mi">1</span>
  <span class="n">Device</span> <span class="n">Name</span>                                     <span class="n">GeForce</span> <span class="n">GTX</span> <span class="mi">1060</span>
  <span class="n">Device</span> <span class="n">Vendor</span>                                   <span class="n">NVIDIA</span> <span class="n">Corporation</span>
  <span class="n">Device</span> <span class="n">Vendor</span> <span class="n">ID</span>                                <span class="mh">0x10de</span>
  <span class="n">Device</span> <span class="n">Version</span>                                  <span class="n">OpenCL</span> <span class="mf">1.2</span> <span class="n">CUDA</span>
  <span class="n">Driver</span> <span class="n">Version</span>                                  <span class="mf">415.18</span>
  <span class="n">Device</span> <span class="n">OpenCL</span> <span class="n">C</span> <span class="n">Version</span>                         <span class="n">OpenCL</span> <span class="n">C</span> <span class="mf">1.2</span>
  <span class="n">Device</span> <span class="n">Type</span>                                     <span class="n">GPU</span>
  <span class="n">Device</span> <span class="n">Topology</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                            <span class="n">PCI</span><span class="o">-</span><span class="n">E</span><span class="p">,</span> <span class="mi">01</span><span class="p">:</span><span class="mf">00.0</span>
  <span class="n">Device</span> <span class="n">Profile</span>                                  <span class="n">FULL_PROFILE</span>
  <span class="n">Device</span> <span class="n">Available</span>                                <span class="n">Yes</span>
  <span class="n">Compiler</span> <span class="n">Available</span>                              <span class="n">Yes</span>
  <span class="n">Linker</span> <span class="n">Available</span>                                <span class="n">Yes</span>
  <span class="n">Max</span> <span class="n">compute</span> <span class="n">units</span>                               <span class="mi">10</span>
  <span class="n">Max</span> <span class="n">clock</span> <span class="n">frequency</span>                             <span class="mi">1670</span><span class="n">MHz</span>
  <span class="n">Compute</span> <span class="n">Capability</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                         <span class="mf">6.1</span>
  <span class="n">Device</span> <span class="n">Partition</span>                                <span class="p">(</span><span class="n">core</span><span class="p">)</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">sub</span><span class="o">-</span><span class="n">devices</span>                     <span class="mi">1</span>
    <span class="n">Supported</span> <span class="n">partition</span> <span class="n">types</span>                     <span class="kc">None</span>
    <span class="n">Supported</span> <span class="n">affinity</span> <span class="n">domains</span>                    <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">dimensions</span>                        <span class="mi">3</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">item</span> <span class="n">sizes</span>                             <span class="mi">1024</span><span class="n">x1024x64</span>
  <span class="n">Max</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span>                             <span class="mi">1024</span>
  <span class="n">Preferred</span> <span class="n">work</span> <span class="n">group</span> <span class="n">size</span> <span class="n">multiple</span>              <span class="mi">32</span>
  <span class="n">Warp</span> <span class="n">size</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                                  <span class="mi">32</span>
  <span class="n">Preferred</span> <span class="o">/</span> <span class="n">native</span> <span class="n">vector</span> <span class="n">sizes</span>
    <span class="n">char</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">short</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="nb">int</span>                                                  <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">long</span>                                                 <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">half</span>                                                 <span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span>        <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">float</span>                                                <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="n">double</span>                                               <span class="mi">1</span> <span class="o">/</span> <span class="mi">1</span>        <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
  <span class="n">Half</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>           <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Single</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">core</span><span class="p">)</span>
    <span class="n">Denormals</span>                                     <span class="n">Yes</span>
    <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
    <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
    <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
    <span class="n">Correctly</span><span class="o">-</span><span class="n">rounded</span> <span class="n">divide</span> <span class="ow">and</span> <span class="n">sqrt</span> <span class="n">operations</span>  <span class="n">Yes</span>
  <span class="n">Double</span><span class="o">-</span><span class="n">precision</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">support</span>         <span class="p">(</span><span class="n">cl_khr_fp64</span><span class="p">)</span>
    <span class="n">Denormals</span>                                     <span class="n">Yes</span>
    <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">NANs</span>                             <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">nearest</span>                              <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">zero</span>                                 <span class="n">Yes</span>
    <span class="n">Round</span> <span class="n">to</span> <span class="n">infinity</span>                             <span class="n">Yes</span>
    <span class="n">IEEE754</span><span class="o">-</span><span class="mi">2008</span> <span class="n">fused</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>               <span class="n">Yes</span>
    <span class="n">Support</span> <span class="ow">is</span> <span class="n">emulated</span> <span class="ow">in</span> <span class="n">software</span>               <span class="n">No</span>
  <span class="n">Address</span> <span class="n">bits</span>                                    <span class="mi">64</span><span class="p">,</span> <span class="n">Little</span><span class="o">-</span><span class="n">Endian</span>
  <span class="n">Global</span> <span class="n">memory</span> <span class="n">size</span>                              <span class="mi">6373572608</span> <span class="p">(</span><span class="mf">5.936</span><span class="n">GiB</span><span class="p">)</span>
  <span class="n">Error</span> <span class="n">Correction</span> <span class="n">support</span>                        <span class="n">No</span>
  <span class="n">Max</span> <span class="n">memory</span> <span class="n">allocation</span>                           <span class="mi">1593393152</span> <span class="p">(</span><span class="mf">1.484</span><span class="n">GiB</span><span class="p">)</span>
  <span class="n">Unified</span> <span class="n">memory</span> <span class="k">for</span> <span class="n">Host</span> <span class="ow">and</span> <span class="n">Device</span>              <span class="n">No</span>
  <span class="n">Integrated</span> <span class="n">memory</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                          <span class="n">No</span>
  <span class="n">Minimum</span> <span class="n">alignment</span> <span class="k">for</span> <span class="nb">any</span> <span class="n">data</span> <span class="nb">type</span>             <span class="mi">128</span> <span class="nb">bytes</span>
  <span class="n">Alignment</span> <span class="n">of</span> <span class="n">base</span> <span class="n">address</span>                       <span class="mi">4096</span> <span class="n">bits</span> <span class="p">(</span><span class="mi">512</span> <span class="nb">bytes</span><span class="p">)</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="nb">type</span>                        <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">size</span>                        <span class="mi">163840</span> <span class="p">(</span><span class="mi">160</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Global</span> <span class="n">Memory</span> <span class="n">cache</span> <span class="n">line</span> <span class="n">size</span>                   <span class="mi">128</span> <span class="nb">bytes</span>
  <span class="n">Image</span> <span class="n">support</span>                                   <span class="n">Yes</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">samplers</span> <span class="n">per</span> <span class="n">kernel</span>             <span class="mi">32</span>
    <span class="n">Max</span> <span class="n">size</span> <span class="k">for</span> <span class="mi">1</span><span class="n">D</span> <span class="n">images</span> <span class="kn">from</span> <span class="nn">buffer</span>            <span class="mi">134217728</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="mi">1</span><span class="n">D</span> <span class="ow">or</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">array</span> <span class="n">size</span>                 <span class="mi">2048</span> <span class="n">images</span>
    <span class="n">Max</span> <span class="mi">2</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x32768</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="mi">3</span><span class="n">D</span> <span class="n">image</span> <span class="n">size</span>                             <span class="mi">16384</span><span class="n">x16384x16384</span> <span class="n">pixels</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">read</span> <span class="n">image</span> <span class="n">args</span>                 <span class="mi">256</span>
    <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">write</span> <span class="n">image</span> <span class="n">args</span>                <span class="mi">16</span>
  <span class="n">Local</span> <span class="n">memory</span> <span class="nb">type</span>                               <span class="n">Local</span>
  <span class="n">Local</span> <span class="n">memory</span> <span class="n">size</span>                               <span class="mi">49152</span> <span class="p">(</span><span class="mi">48</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Registers</span> <span class="n">per</span> <span class="n">block</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                        <span class="mi">65536</span>
  <span class="n">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">args</span>                     <span class="mi">9</span>
  <span class="n">Max</span> <span class="n">constant</span> <span class="n">buffer</span> <span class="n">size</span>                        <span class="mi">65536</span> <span class="p">(</span><span class="mi">64</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">size</span> <span class="n">of</span> <span class="n">kernel</span> <span class="n">argument</span>                     <span class="mi">4352</span> <span class="p">(</span><span class="mf">4.25</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Queue</span> <span class="n">properties</span>
    <span class="n">Out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">order</span> <span class="n">execution</span>                        <span class="n">Yes</span>
    <span class="n">Profiling</span>                                     <span class="n">Yes</span>
  <span class="n">Prefer</span> <span class="n">user</span> <span class="n">sync</span> <span class="k">for</span> <span class="n">interop</span>                    <span class="n">No</span>
  <span class="n">Profiling</span> <span class="n">timer</span> <span class="n">resolution</span>                      <span class="mi">1000</span><span class="n">ns</span>
  <span class="n">Execution</span> <span class="n">capabilities</span>
    <span class="n">Run</span> <span class="n">OpenCL</span> <span class="n">kernels</span>                            <span class="n">Yes</span>
    <span class="n">Run</span> <span class="n">native</span> <span class="n">kernels</span>                            <span class="n">No</span>
    <span class="n">Kernel</span> <span class="n">execution</span> <span class="n">timeout</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>                 <span class="n">No</span>
  <span class="n">Concurrent</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">kernel</span> <span class="n">execution</span> <span class="p">(</span><span class="n">NV</span><span class="p">)</span>       <span class="n">Yes</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="k">async</span> <span class="n">copy</span> <span class="n">engines</span>                  <span class="mi">2</span>
  <span class="n">printf</span><span class="p">()</span> <span class="n">buffer</span> <span class="n">size</span>                            <span class="mi">1048576</span> <span class="p">(</span><span class="mi">1024</span><span class="n">KiB</span><span class="p">)</span>
  <span class="n">Built</span><span class="o">-</span><span class="ow">in</span> <span class="n">kernels</span>                                <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
  <span class="n">Device</span> <span class="n">Extensions</span>                               <span class="n">cl_khr_global_int32_base_atomics</span> <span class="n">cl_khr_global_int32_extended_atomics</span> <span class="n">cl_khr_local_int32_base_atomics</span> <span class="n">cl_khr_local_int32_extended_atomics</span> <span class="n">cl_khr_fp64</span> <span class="n">cl_khr_byte_addressable_store</span> <span class="n">cl_khr_icd</span> <span class="n">cl_khr_gl_sharing</span> <span class="n">cl_nv_compiler_options</span> <span class="n">cl_nv_device_attribute_query</span> <span class="n">cl_nv_pragma_unroll</span> <span class="n">cl_nv_copy_opts</span> <span class="n">cl_nv_create_buffer</span>
</pre></div>
</div>
<p><strong>AMD GPU</strong></p>
<p>AMD has very good support for OpenCL. See AMDGPU-PRO driver.</p>
<p><strong>Open-source Intel Compute OpenCL (Intel-NEO and Intel SDK)</strong></p>
<p>Try to install Intel’s proprietary OpenCL sdk.</p>
</div>
</div>
</div>
</div>
<span id="document-versionhistory"></span><div class="section" id="version-history">
<h2>Version history<a class="headerlink" href="#version-history" title="Permalink to this headline">¶</a></h2>
<p><strong>v2020.1.0</strong></p>
<ul class="simple">
<li><p>add batch mode to nudft_cpu</p></li>
</ul>
<p><strong>v2020.0.0</strong></p>
<ul class="simple">
<li><p>fix batch=1. This can cause error in Riekna fft.</p></li>
</ul>
<p><strong>v2019.2.3</strong></p>
<p>-(experimental) Add the unified NUFFT() class. Now CPU, GPU, and legacy GPU mode are encapsuled in a single class.</p>
<p>-Tested using Intel Neo OpenCL driver (see <a class="reference external" href="https://github.com/intel/compute-runtime">https://github.com/intel/compute-runtime</a>) and IntelPython3.</p>
<p>-The old NUFFT_cpu() and NUFFT_legacy() will be kept in the system for compatibility.</p>
<p><strong>v2019.2.1-2019.2.2</strong></p>
<p>-Remove lsmr as scipy 1.13 has caused unknown error.</p>
<p><strong>v2019.2.0</strong></p>
<ul class="simple">
<li><p>Bump</p></li>
</ul>
<p><strong>v2019.1.2</strong></p>
<ul class="simple">
<li><p>BUGFIX: fix the loss of accuracy in cSpmvh(). Replace the group/local by global memory (the group/local sizes have caused the unknown run-time behaviour on cuda)</p></li>
</ul>
<p><strong>v2019.1.1</strong></p>
<ul class="simple">
<li><p>Refactor the re_subroutine.py</p></li>
<li><p>Adopt tensor form</p></li>
</ul>
<p><strong>v0.4.0.0</strong></p>
<ul class="simple">
<li><p>0.4.0.0 is a beta version.</p></li>
<li><p>Major updates for the NUFFT_hsa class, including memory reduction and split-radix. Multiple NUFFT_hsa() using cuda backend becomes possible, by pushing the context to the top of the stack when a method is called.</p></li>
<li><p>Tested in Windows 10 with PyCUDA 2018.1.1, nvidia-driver 417.35, CUDA 9.2, Visual Studio 2015 Community, and Anaconda Python 3.7 64-bit. PyOpenCL in Windows is yet to be tested.</p></li>
<li><p>Add batch mode.</p></li>
</ul>
<p><strong>v0.3.3.12</strong></p>
<ul class="simple">
<li><p>0.3.3.12 is a bug-fixed version.</p></li>
<li><p>Removal of the keyword async for compatibility reasons because Reikna has changed the keyword to <a href="#id1"><span class="problematic" id="id2">async_</span></a>.</p></li>
</ul>
<p><strong>v0.3.3.8</strong></p>
<ul class="simple">
<li><p>Bugfix: mm = numpy.tile(mm, [numpy.prod(Jd).astype(int), 1])  to fix the wrong type when numpy.prod(Jd) is not cast as int</p></li>
<li><p>Bugfix: fix rcond=None error in Anaconda 3.6.5 and Numpy 1.13.1 (the recommended None in Numpy 1.14 is backward incompatible with 1.13)</p></li>
<li><p>Bugfix:  indx1 = indx.copy() is replaced by indx1 = list(indx) for Python2 compatibility</p></li>
</ul>
<p><strong>v0.3.3.7</strong></p>
<ul class="simple">
<li><p>Bugfix in 0.3.3.7 Toeplitz is removed from the NUFFT_cpu and NUFFT_gpu to avoid the MemoryError.</p></li>
</ul>
<p><strong>v0.3.3.6</strong></p>
<ul class="simple">
<li><p>Bugfix: correct the error of import. Now import NUFFT_cpu, NUFFT_hsa at the top level.</p></li>
</ul>
<p><strong>v0.3.3</strong></p>
<ul class="simple">
<li><p>Note: GPU support is superseded by Heterogeneous System Architecture (HSA).</p></li>
<li><p>A variety of nonlinear solvers are provided, including the conjugate gradient method (cg), L1 total-variation ordinary least square (L1TVOLS), and L1 total-variation least absolute deviation (L1TVLAD).</p></li>
<li><p>The CPU version support other nonlinear solvers, lsqr, gmr, cg, bicgstab, bicg, cgs, gmres, lgmres , apart from cg, L1TVOLS and L1TVLAD.</p></li>
<li><p>Support multi-dimensional transform and reconstruction (experimentally).</p></li>
</ul>
<p><strong>v0.3.2.9</strong></p>
<ul class="simple">
<li><p>Experimental support of NVIDIA’s graphic processing unit (GPU).</p></li>
<li><p>The experimental class gpuNUFFT requires pycuda, scikit-cuda, and python-cuda-cffi. scikit-cuda can be installed from standard command.</p></li>
</ul>
<p><strong>v0.3.2.8</strong></p>
<ul class="simple">
<li><p>Tested under Linux and Windows Anaconda3</p></li>
</ul>
<p><strong>v0.3</strong></p>
<ul class="simple">
<li><p>Updated setup.py</p></li>
<li><p>Removal of pyfftw due to segfault under some Linux distributions</p></li>
</ul>
</div>
<span id="document-acknow/init"></span><div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>I would be more than grateful for what
contributors have done (either contributing codes or fixing bugs in pynufft).
However, The information of contributors and partners are kept anonymized without
their prior express informed consent.
If anyone would like to be identified as a contributors/partners, please contact <a class="reference external" href="mailto:pynufft&#37;&#52;&#48;gmail&#46;com">pynufft<span>&#64;</span>gmail<span>&#46;</span>com</a>.</p>
<p><strong>Financial supports</strong></p>
<p>Cambridge Commonwealth, European and International Trust (Cambridge, UK)</p>
<p>Ministry of Education (Taiwan)</p>
<p>NVIDIA Corp for donating Titan X Pascal.</p>
<p>The * project (The <a href="#id1"><span class="problematic" id="id2">*</span></a>, * and <a href="#id3"><span class="problematic" id="id4">*</span></a>)</p>
<p>The * project</p>
<p><strong>Contributors and partners</strong></p>
<p>R******</p>
<p>T******</p>
<p>H******</p>
<p>J******</p>
<p>W*****</p>
<p>I******</p>
<p>A*****</p>
<p>A*****</p>
<p>B*****</p>
<p>D******</p>
<p>M*****</p>
<p>C******</p>
<p>C*****</p>
<p>J*****</p>
<p>J******</p>
<p>The <strong>*</strong> project (The <a href="#id5"><span class="problematic" id="id6">*</span></a>, * and <a href="#id7"><span class="problematic" id="id8">*</span></a>)</p>
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="contact-information">
<h2>Contact information<a class="headerlink" href="#contact-information" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="mailto:pynufft&#37;&#52;&#48;gmail&#46;com">pynufft<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</div>
</div>


          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="#">PyNUFFT 2020.2.1  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PyNUFFT 2020.2.1  documentation</a></li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2012-2020, PyNUFFT services. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>